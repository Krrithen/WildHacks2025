{"ast":null,"code":"let _Symbol$for, _Symbol$for2;\nfunction _classPrivateFieldLooseBase(receiver, privateKey) {\n  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n    throw new TypeError(\"attempted to use private field on non-instance\");\n  }\n  return receiver;\n}\nvar id = 0;\nfunction _classPrivateFieldLooseKey(name) {\n  return \"__private_\" + id++ + \"_\" + name;\n}\n/* eslint-disable max-classes-per-file */\n/* global AggregateError */\n\nimport Translator from '@uppy/utils/lib/Translator';\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore untyped\nimport ee from 'namespace-emitter';\nimport { nanoid } from 'nanoid/non-secure';\nimport throttle from 'lodash/throttle.js';\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore store-default types not always available on that branch\nimport DefaultStore from '@uppy/store-default';\nimport getFileType from '@uppy/utils/lib/getFileType';\nimport getFileNameAndExtension from '@uppy/utils/lib/getFileNameAndExtension';\nimport { getSafeFileId } from '@uppy/utils/lib/generateFileID';\nimport supportsUploadProgress from \"./supportsUploadProgress.js\";\nimport getFileName from \"./getFileName.js\";\nimport { justErrorsLogger, debugLogger } from \"./loggers.js\";\nimport { Restricter, defaultOptions as defaultRestrictionOptions, RestrictionError } from \"./Restricter.js\";\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore We don't want TS to generate types for the package.json\nconst packageJson = {\n  \"version\": \"3.13.1\"\n};\nimport locale from \"./locale.js\";\n\n/*\n * UnknownProviderPlugin can be any Companion plugin (such as Google Drive).\n * As the plugins are passed around throughout Uppy we need a generic type for this.\n * It may seems like duplication, but this type safe. Changing the type of `storage`\n * will error in the `Provider` class of @uppy/companion-client and vice versa.\n *\n * Note that this is the *plugin* class, not a version of the `Provider` class.\n * `Provider` does operate on Companion plugins with `uppy.getPlugin()`.\n */\n\n/*\n * UnknownSearchProviderPlugin can be any search Companion plugin (such as Unsplash).\n * As the plugins are passed around throughout Uppy we need a generic type for this.\n * It may seems like duplication, but this type safe. Changing the type of `title`\n * will error in the `SearchProvider` class of @uppy/companion-client and vice versa.\n *\n * Note that this is the *plugin* class, not a version of the `SearchProvider` class.\n * `SearchProvider` does operate on Companion plugins with `uppy.getPlugin()`.\n */\n\n// TODO: can we use namespaces in other plugins to populate this?\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\n\n// The user facing type for UppyOptions used in uppy.setOptions()\n\n/** @deprecated */\n\nconst defaultUploadState = {\n  totalProgress: 0,\n  allowNewUpload: true,\n  error: null,\n  recoveredState: null\n};\n\n/**\n * Uppy Core module.\n * Manages plugins, state updates, acts as an event bus,\n * adds/removes files and metadata.\n */\nvar _plugins = /*#__PURE__*/_classPrivateFieldLooseKey(\"plugins\");\nvar _restricter = /*#__PURE__*/_classPrivateFieldLooseKey(\"restricter\");\nvar _storeUnsubscribe = /*#__PURE__*/_classPrivateFieldLooseKey(\"storeUnsubscribe\");\nvar _emitter = /*#__PURE__*/_classPrivateFieldLooseKey(\"emitter\");\nvar _preProcessors = /*#__PURE__*/_classPrivateFieldLooseKey(\"preProcessors\");\nvar _uploaders = /*#__PURE__*/_classPrivateFieldLooseKey(\"uploaders\");\nvar _postProcessors = /*#__PURE__*/_classPrivateFieldLooseKey(\"postProcessors\");\nvar _informAndEmit = /*#__PURE__*/_classPrivateFieldLooseKey(\"informAndEmit\");\nvar _checkRequiredMetaFieldsOnFile = /*#__PURE__*/_classPrivateFieldLooseKey(\"checkRequiredMetaFieldsOnFile\");\nvar _checkRequiredMetaFields = /*#__PURE__*/_classPrivateFieldLooseKey(\"checkRequiredMetaFields\");\nvar _assertNewUploadAllowed = /*#__PURE__*/_classPrivateFieldLooseKey(\"assertNewUploadAllowed\");\nvar _transformFile = /*#__PURE__*/_classPrivateFieldLooseKey(\"transformFile\");\nvar _startIfAutoProceed = /*#__PURE__*/_classPrivateFieldLooseKey(\"startIfAutoProceed\");\nvar _checkAndUpdateFileState = /*#__PURE__*/_classPrivateFieldLooseKey(\"checkAndUpdateFileState\");\nvar _addListeners = /*#__PURE__*/_classPrivateFieldLooseKey(\"addListeners\");\nvar _updateOnlineStatus = /*#__PURE__*/_classPrivateFieldLooseKey(\"updateOnlineStatus\");\nvar _requestClientById = /*#__PURE__*/_classPrivateFieldLooseKey(\"requestClientById\");\nvar _createUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"createUpload\");\nvar _getUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"getUpload\");\nvar _removeUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"removeUpload\");\nvar _runUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"runUpload\");\n_Symbol$for = Symbol.for('uppy test: getPlugins');\n_Symbol$for2 = Symbol.for('uppy test: createUpload');\nexport class Uppy {\n  /**\n   * Instantiate Uppy\n   */\n  constructor(_opts) {\n    /**\n     * Run an upload. This picks up where it left off in case the upload is being restored.\n     */\n    Object.defineProperty(this, _runUpload, {\n      value: _runUpload2\n    });\n    /**\n     * Remove an upload, eg. if it has been canceled or completed.\n     *\n     */\n    Object.defineProperty(this, _removeUpload, {\n      value: _removeUpload2\n    });\n    Object.defineProperty(this, _getUpload, {\n      value: _getUpload2\n    });\n    /**\n     * Create an upload for a bunch of files.\n     *\n     */\n    Object.defineProperty(this, _createUpload, {\n      value: _createUpload2\n    });\n    /**\n     * Registers listeners for all global actions, like:\n     * `error`, `file-removed`, `upload-progress`\n     */\n    Object.defineProperty(this, _addListeners, {\n      value: _addListeners2\n    });\n    Object.defineProperty(this, _checkAndUpdateFileState, {\n      value: _checkAndUpdateFileState2\n    });\n    // Schedule an upload if `autoProceed` is enabled.\n    Object.defineProperty(this, _startIfAutoProceed, {\n      value: _startIfAutoProceed2\n    });\n    /**\n     * Create a file state object based on user-provided `addFile()` options.\n     */\n    Object.defineProperty(this, _transformFile, {\n      value: _transformFile2\n    });\n    Object.defineProperty(this, _assertNewUploadAllowed, {\n      value: _assertNewUploadAllowed2\n    });\n    Object.defineProperty(this, _checkRequiredMetaFields, {\n      value: _checkRequiredMetaFields2\n    });\n    Object.defineProperty(this, _checkRequiredMetaFieldsOnFile, {\n      value: _checkRequiredMetaFieldsOnFile2\n    });\n    Object.defineProperty(this, _informAndEmit, {\n      value: _informAndEmit2\n    });\n    Object.defineProperty(this, _plugins, {\n      writable: true,\n      value: Object.create(null)\n    });\n    Object.defineProperty(this, _restricter, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _storeUnsubscribe, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _emitter, {\n      writable: true,\n      value: ee()\n    });\n    Object.defineProperty(this, _preProcessors, {\n      writable: true,\n      value: new Set()\n    });\n    Object.defineProperty(this, _uploaders, {\n      writable: true,\n      value: new Set()\n    });\n    Object.defineProperty(this, _postProcessors, {\n      writable: true,\n      value: new Set()\n    });\n    this.scheduledAutoProceed = null;\n    this.wasOffline = false;\n    // ___Why throttle at 500ms?\n    //    - We must throttle at >250ms for superfocus in Dashboard to work well\n    //    (because animation takes 0.25s, and we want to wait for all animations to be over before refocusing).\n    //    [Practical Check]: if thottle is at 100ms, then if you are uploading a file,\n    //    and click 'ADD MORE FILES', - focus won't activate in Firefox.\n    //    - We must throttle at around >500ms to avoid performance lags.\n    //    [Practical Check] Firefox, try to upload a big file for a prolonged period of time. Laptop will start to heat up.\n    // todo when uploading multiple files, this will cause problems because they share the same throttle,\n    // meaning some files might never get their progress reported (eaten up by progress events from other files)\n    this.calculateProgress = throttle((file, data) => {\n      const fileInState = this.getFile(file == null ? void 0 : file.id);\n      if (file == null || !fileInState) {\n        this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);\n        return;\n      }\n      if (fileInState.progress.percentage === 100) {\n        this.log(`Not setting progress for a file that has been already uploaded: ${file.id}`);\n        return;\n      }\n\n      // bytesTotal may be null or zero; in that case we can't divide by it\n      const canHavePercentage = Number.isFinite(data.bytesTotal) && data.bytesTotal > 0;\n      this.setFileState(file.id, {\n        progress: {\n          ...fileInState.progress,\n          bytesUploaded: data.bytesUploaded,\n          bytesTotal: data.bytesTotal,\n          percentage: canHavePercentage ? Math.round(data.bytesUploaded / data.bytesTotal * 100) : 0\n        }\n      });\n      this.calculateTotalProgress();\n    }, 500, {\n      leading: true,\n      trailing: true\n    });\n    Object.defineProperty(this, _updateOnlineStatus, {\n      writable: true,\n      value: this.updateOnlineStatus.bind(this)\n    });\n    // We need to store request clients by a unique ID, so we can share RequestClient instances across files\n    // this allows us to do rate limiting and synchronous operations like refreshing provider tokens\n    // example: refreshing tokens: if each file has their own requestclient,\n    // we don't have any way to synchronize all requests in order to\n    // - block all requests\n    // - refresh the token\n    // - unblock all requests and allow them to run with a the new access token\n    // back when we had a requestclient per file, once an access token expired,\n    // all 6 files would go ahead and refresh the token at the same time\n    // (calling /refresh-token up to 6 times), which will probably fail for some providers\n    Object.defineProperty(this, _requestClientById, {\n      writable: true,\n      value: new Map()\n    });\n    this.defaultLocale = locale;\n    const defaultOptions = {\n      id: 'uppy',\n      autoProceed: false,\n      allowMultipleUploadBatches: true,\n      debug: false,\n      restrictions: defaultRestrictionOptions,\n      meta: {},\n      onBeforeFileAdded: (file, files) => !Object.hasOwn(files, file.id),\n      onBeforeUpload: files => files,\n      store: new DefaultStore(),\n      logger: justErrorsLogger,\n      infoTimeout: 5000\n    };\n    const merged = {\n      ...defaultOptions,\n      ..._opts\n    };\n    // Merge default options with the ones set by user,\n    // making sure to merge restrictions too\n    this.opts = {\n      ...merged,\n      restrictions: {\n        ...defaultOptions.restrictions,\n        ...(_opts && _opts.restrictions)\n      }\n    };\n\n    // Support debug: true for backwards-compatability, unless logger is set in opts\n    // opts instead of this.opts to avoid comparing objects — we set logger: justErrorsLogger in defaultOptions\n    if (_opts && _opts.logger && _opts.debug) {\n      this.log('You are using a custom `logger`, but also set `debug: true`, which uses built-in logger to output logs to console. Ignoring `debug: true` and using your custom `logger`.', 'warning');\n    } else if (_opts && _opts.debug) {\n      this.opts.logger = debugLogger;\n    }\n    this.log(`Using Core v${Uppy.VERSION}`);\n    this.i18nInit();\n    this.store = this.opts.store;\n    this.setState({\n      ...defaultUploadState,\n      plugins: {},\n      files: {},\n      currentUploads: {},\n      capabilities: {\n        uploadProgress: supportsUploadProgress(),\n        individualCancellation: true,\n        resumableUploads: false\n      },\n      meta: {\n        ...this.opts.meta\n      },\n      info: []\n    });\n    _classPrivateFieldLooseBase(this, _restricter)[_restricter] = new Restricter(() => this.opts, () => this.i18n);\n    _classPrivateFieldLooseBase(this, _storeUnsubscribe)[_storeUnsubscribe] = this.store.subscribe(\n    // eslint-disable-next-line\n    // @ts-ignore Store is incorrectly typed\n    (prevState, nextState, patch) => {\n      // eslint-disable-next-line\n      // @ts-ignore Store is incorrectly typed\n      this.emit('state-update', prevState, nextState, patch);\n      this.updateAll(nextState);\n    });\n\n    // Exposing uppy object on window for debugging and testing\n    if (this.opts.debug && typeof window !== 'undefined') {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore Mutating the global object for debug purposes\n      window[this.opts.id] = this;\n    }\n    _classPrivateFieldLooseBase(this, _addListeners)[_addListeners]();\n  }\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    _classPrivateFieldLooseBase(this, _emitter)[_emitter].emit(event, ...args);\n  }\n  on(event, callback) {\n    _classPrivateFieldLooseBase(this, _emitter)[_emitter].on(event, callback);\n    return this;\n  }\n  once(event, callback) {\n    _classPrivateFieldLooseBase(this, _emitter)[_emitter].once(event, callback);\n    return this;\n  }\n  off(event, callback) {\n    _classPrivateFieldLooseBase(this, _emitter)[_emitter].off(event, callback);\n    return this;\n  }\n\n  /**\n   * Iterate on all plugins and run `update` on them.\n   * Called each time state changes.\n   *\n   */\n  updateAll(state) {\n    this.iteratePlugins(plugin => {\n      plugin.update(state);\n    });\n  }\n\n  /**\n   * Updates state with a patch\n   */\n  setState(patch) {\n    // eslint-disable-next-line\n    // @ts-ignore Store is incorrectly typed\n    this.store.setState(patch);\n  }\n\n  /**\n   * Returns current state.\n   */\n  getState() {\n    // eslint-disable-next-line\n    // @ts-ignore Store is incorrectly typed\n    return this.store.getState();\n  }\n  patchFilesState(filesWithNewState) {\n    const existingFilesState = this.getState().files;\n    this.setState({\n      files: {\n        ...existingFilesState,\n        ...Object.fromEntries(Object.entries(filesWithNewState).map(_ref => {\n          let [fileID, newFileState] = _ref;\n          return [fileID, {\n            ...existingFilesState[fileID],\n            ...newFileState\n          }];\n        }))\n      }\n    });\n  }\n\n  /**\n   * Shorthand to set state for a specific file.\n   */\n  setFileState(fileID, state) {\n    if (!this.getState().files[fileID]) {\n      throw new Error(`Can’t set state for ${fileID} (the file could have been removed)`);\n    }\n    this.patchFilesState({\n      [fileID]: state\n    });\n  }\n  i18nInit() {\n    const onMissingKey = key => this.log(`Missing i18n string: ${key}`, 'error');\n    const translator = new Translator([this.defaultLocale, this.opts.locale], {\n      onMissingKey\n    });\n    this.i18n = translator.translate.bind(translator);\n    this.i18nArray = translator.translateArray.bind(translator);\n    this.locale = translator.locale;\n  }\n  setOptions(newOpts) {\n    this.opts = {\n      ...this.opts,\n      ...newOpts,\n      restrictions: {\n        ...this.opts.restrictions,\n        ...(newOpts == null ? void 0 : newOpts.restrictions)\n      }\n    };\n    if (newOpts.meta) {\n      this.setMeta(newOpts.meta);\n    }\n    this.i18nInit();\n    if (newOpts.locale) {\n      this.iteratePlugins(plugin => {\n        plugin.setOptions(newOpts);\n      });\n    }\n\n    // Note: this is not the preact `setState`, it's an internal function that has the same name.\n    this.setState(undefined); // so that UI re-renders with new options\n  }\n\n  // todo next major: remove\n  resetProgress() {\n    const defaultProgress = {\n      percentage: 0,\n      bytesUploaded: 0,\n      uploadComplete: false,\n      uploadStarted: null\n    };\n    const files = {\n      ...this.getState().files\n    };\n    const updatedFiles = {};\n    Object.keys(files).forEach(fileID => {\n      updatedFiles[fileID] = {\n        ...files[fileID],\n        progress: {\n          ...files[fileID].progress,\n          ...defaultProgress\n        }\n      };\n    });\n    this.setState({\n      files: updatedFiles,\n      ...defaultUploadState\n    });\n    this.emit('reset-progress');\n  }\n\n  // @todo next major: rename to `clear()`, make it also cancel ongoing uploads\n  // or throw and say you need to cancel manually\n  clearUploadedFiles() {\n    const {\n      capabilities,\n      currentUploads\n    } = this.getState();\n    if (Object.keys(currentUploads).length > 0 && !capabilities.individualCancellation) {\n      throw new Error('The installed uploader plugin does not allow removing files during an upload.');\n    }\n    this.setState({\n      ...defaultUploadState,\n      files: {}\n    });\n  }\n  addPreProcessor(fn) {\n    _classPrivateFieldLooseBase(this, _preProcessors)[_preProcessors].add(fn);\n  }\n  removePreProcessor(fn) {\n    return _classPrivateFieldLooseBase(this, _preProcessors)[_preProcessors].delete(fn);\n  }\n  addPostProcessor(fn) {\n    _classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors].add(fn);\n  }\n  removePostProcessor(fn) {\n    return _classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors].delete(fn);\n  }\n  addUploader(fn) {\n    _classPrivateFieldLooseBase(this, _uploaders)[_uploaders].add(fn);\n  }\n  removeUploader(fn) {\n    return _classPrivateFieldLooseBase(this, _uploaders)[_uploaders].delete(fn);\n  }\n  setMeta(data) {\n    const updatedMeta = {\n      ...this.getState().meta,\n      ...data\n    };\n    const updatedFiles = {\n      ...this.getState().files\n    };\n    Object.keys(updatedFiles).forEach(fileID => {\n      updatedFiles[fileID] = {\n        ...updatedFiles[fileID],\n        meta: {\n          ...updatedFiles[fileID].meta,\n          ...data\n        }\n      };\n    });\n    this.log('Adding metadata:');\n    this.log(data);\n    this.setState({\n      meta: updatedMeta,\n      files: updatedFiles\n    });\n  }\n  setFileMeta(fileID, data) {\n    const updatedFiles = {\n      ...this.getState().files\n    };\n    if (!updatedFiles[fileID]) {\n      this.log('Was trying to set metadata for a file that has been removed: ', fileID);\n      return;\n    }\n    const newMeta = {\n      ...updatedFiles[fileID].meta,\n      ...data\n    };\n    updatedFiles[fileID] = {\n      ...updatedFiles[fileID],\n      meta: newMeta\n    };\n    this.setState({\n      files: updatedFiles\n    });\n  }\n\n  /**\n   * Get a file object.\n   */\n  getFile(fileID) {\n    return this.getState().files[fileID];\n  }\n\n  /**\n   * Get all files in an array.\n   */\n  getFiles() {\n    const {\n      files\n    } = this.getState();\n    return Object.values(files);\n  }\n  getFilesByIds(ids) {\n    return ids.map(id => this.getFile(id));\n  }\n  getObjectOfFilesPerState() {\n    const {\n      files: filesObject,\n      totalProgress,\n      error\n    } = this.getState();\n    const files = Object.values(filesObject);\n    const inProgressFiles = [];\n    const newFiles = [];\n    const startedFiles = [];\n    const uploadStartedFiles = [];\n    const pausedFiles = [];\n    const completeFiles = [];\n    const erroredFiles = [];\n    const inProgressNotPausedFiles = [];\n    const processingFiles = [];\n    for (const file of files) {\n      const {\n        progress\n      } = file;\n      if (!progress.uploadComplete && progress.uploadStarted) {\n        inProgressFiles.push(file);\n        if (!file.isPaused) {\n          inProgressNotPausedFiles.push(file);\n        }\n      }\n      if (!progress.uploadStarted) {\n        newFiles.push(file);\n      }\n      if (progress.uploadStarted || progress.preprocess || progress.postprocess) {\n        startedFiles.push(file);\n      }\n      if (progress.uploadStarted) {\n        uploadStartedFiles.push(file);\n      }\n      if (file.isPaused) {\n        pausedFiles.push(file);\n      }\n      if (progress.uploadComplete) {\n        completeFiles.push(file);\n      }\n      if (file.error) {\n        erroredFiles.push(file);\n      }\n      if (progress.preprocess || progress.postprocess) {\n        processingFiles.push(file);\n      }\n    }\n    return {\n      newFiles,\n      startedFiles,\n      uploadStartedFiles,\n      pausedFiles,\n      completeFiles,\n      erroredFiles,\n      inProgressFiles,\n      inProgressNotPausedFiles,\n      processingFiles,\n      isUploadStarted: uploadStartedFiles.length > 0,\n      isAllComplete: totalProgress === 100 && completeFiles.length === files.length && processingFiles.length === 0,\n      isAllErrored: !!error && erroredFiles.length === files.length,\n      isAllPaused: inProgressFiles.length !== 0 && pausedFiles.length === inProgressFiles.length,\n      isUploadInProgress: inProgressFiles.length > 0,\n      isSomeGhost: files.some(file => file.isGhost)\n    };\n  }\n  validateRestrictions(file, files) {\n    if (files === void 0) {\n      files = this.getFiles();\n    }\n    try {\n      _classPrivateFieldLooseBase(this, _restricter)[_restricter].validate(files, [file]);\n    } catch (err) {\n      return err;\n    }\n    return null;\n  }\n  checkIfFileAlreadyExists(fileID) {\n    const {\n      files\n    } = this.getState();\n    if (files[fileID] && !files[fileID].isGhost) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Add a new file to `state.files`. This will run `onBeforeFileAdded`,\n   * try to guess file type in a clever way, check file against restrictions,\n   * and start an upload if `autoProceed === true`.\n   */\n  addFile(file) {\n    _classPrivateFieldLooseBase(this, _assertNewUploadAllowed)[_assertNewUploadAllowed](file);\n    const {\n      nextFilesState,\n      validFilesToAdd,\n      errors\n    } = _classPrivateFieldLooseBase(this, _checkAndUpdateFileState)[_checkAndUpdateFileState]([file]);\n    const restrictionErrors = errors.filter(error => error.isRestriction);\n    _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit](restrictionErrors);\n    if (errors.length > 0) throw errors[0];\n    this.setState({\n      files: nextFilesState\n    });\n    const [firstValidFileToAdd] = validFilesToAdd;\n    this.emit('file-added', firstValidFileToAdd);\n    this.emit('files-added', validFilesToAdd);\n    this.log(`Added file: ${firstValidFileToAdd.name}, ${firstValidFileToAdd.id}, mime type: ${firstValidFileToAdd.type}`);\n    _classPrivateFieldLooseBase(this, _startIfAutoProceed)[_startIfAutoProceed]();\n    return firstValidFileToAdd.id;\n  }\n\n  /**\n   * Add multiple files to `state.files`. See the `addFile()` documentation.\n   *\n   * If an error occurs while adding a file, it is logged and the user is notified.\n   * This is good for UI plugins, but not for programmatic use.\n   * Programmatic users should usually still use `addFile()` on individual files.\n   */\n  addFiles(fileDescriptors) {\n    _classPrivateFieldLooseBase(this, _assertNewUploadAllowed)[_assertNewUploadAllowed]();\n    const {\n      nextFilesState,\n      validFilesToAdd,\n      errors\n    } = _classPrivateFieldLooseBase(this, _checkAndUpdateFileState)[_checkAndUpdateFileState](fileDescriptors);\n    const restrictionErrors = errors.filter(error => error.isRestriction);\n    _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit](restrictionErrors);\n    const nonRestrictionErrors = errors.filter(error => !error.isRestriction);\n    if (nonRestrictionErrors.length > 0) {\n      let message = 'Multiple errors occurred while adding files:\\n';\n      nonRestrictionErrors.forEach(subError => {\n        message += `\\n * ${subError.message}`;\n      });\n      this.info({\n        message: this.i18n('addBulkFilesFailed', {\n          smart_count: nonRestrictionErrors.length\n        }),\n        details: message\n      }, 'error', this.opts.infoTimeout);\n      if (typeof AggregateError === 'function') {\n        throw new AggregateError(nonRestrictionErrors, message);\n      } else {\n        const err = new Error(message);\n        // @ts-expect-error fallback when AggregateError is not available\n        err.errors = nonRestrictionErrors;\n        throw err;\n      }\n    }\n\n    // OK, we haven't thrown an error, we can start updating state and emitting events now:\n\n    this.setState({\n      files: nextFilesState\n    });\n    validFilesToAdd.forEach(file => {\n      this.emit('file-added', file);\n    });\n    this.emit('files-added', validFilesToAdd);\n    if (validFilesToAdd.length > 5) {\n      this.log(`Added batch of ${validFilesToAdd.length} files`);\n    } else {\n      Object.values(validFilesToAdd).forEach(file => {\n        this.log(`Added file: ${file.name}\\n id: ${file.id}\\n type: ${file.type}`);\n      });\n    }\n    if (validFilesToAdd.length > 0) {\n      _classPrivateFieldLooseBase(this, _startIfAutoProceed)[_startIfAutoProceed]();\n    }\n  }\n  removeFiles(fileIDs, reason) {\n    const {\n      files,\n      currentUploads\n    } = this.getState();\n    const updatedFiles = {\n      ...files\n    };\n    const updatedUploads = {\n      ...currentUploads\n    };\n    const removedFiles = Object.create(null);\n    fileIDs.forEach(fileID => {\n      if (files[fileID]) {\n        removedFiles[fileID] = files[fileID];\n        delete updatedFiles[fileID];\n      }\n    });\n\n    // Remove files from the `fileIDs` list in each upload.\n    function fileIsNotRemoved(uploadFileID) {\n      return removedFiles[uploadFileID] === undefined;\n    }\n    Object.keys(updatedUploads).forEach(uploadID => {\n      const newFileIDs = currentUploads[uploadID].fileIDs.filter(fileIsNotRemoved);\n\n      // Remove the upload if no files are associated with it anymore.\n      if (newFileIDs.length === 0) {\n        delete updatedUploads[uploadID];\n        return;\n      }\n      const {\n        capabilities\n      } = this.getState();\n      if (newFileIDs.length !== currentUploads[uploadID].fileIDs.length && !capabilities.individualCancellation) {\n        throw new Error('The installed uploader plugin does not allow removing files during an upload.');\n      }\n      updatedUploads[uploadID] = {\n        ...currentUploads[uploadID],\n        fileIDs: newFileIDs\n      };\n    });\n    const stateUpdate = {\n      currentUploads: updatedUploads,\n      files: updatedFiles\n    };\n\n    // If all files were removed - allow new uploads,\n    // and clear recoveredState\n    if (Object.keys(updatedFiles).length === 0) {\n      stateUpdate.allowNewUpload = true;\n      stateUpdate.error = null;\n      stateUpdate.recoveredState = null;\n    }\n    this.setState(stateUpdate);\n    this.calculateTotalProgress();\n    const removedFileIDs = Object.keys(removedFiles);\n    removedFileIDs.forEach(fileID => {\n      this.emit('file-removed', removedFiles[fileID], reason);\n    });\n    if (removedFileIDs.length > 5) {\n      this.log(`Removed ${removedFileIDs.length} files`);\n    } else {\n      this.log(`Removed files: ${removedFileIDs.join(', ')}`);\n    }\n  }\n  removeFile(fileID, reason) {\n    this.removeFiles([fileID], reason);\n  }\n  pauseResume(fileID) {\n    if (!this.getState().capabilities.resumableUploads || this.getFile(fileID).progress.uploadComplete) {\n      return undefined;\n    }\n    const wasPaused = this.getFile(fileID).isPaused || false;\n    const isPaused = !wasPaused;\n    this.setFileState(fileID, {\n      isPaused\n    });\n    this.emit('upload-pause', fileID, isPaused);\n    return isPaused;\n  }\n  pauseAll() {\n    const updatedFiles = {\n      ...this.getState().files\n    };\n    const inProgressUpdatedFiles = Object.keys(updatedFiles).filter(file => {\n      return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;\n    });\n    inProgressUpdatedFiles.forEach(file => {\n      const updatedFile = {\n        ...updatedFiles[file],\n        isPaused: true\n      };\n      updatedFiles[file] = updatedFile;\n    });\n    this.setState({\n      files: updatedFiles\n    });\n    this.emit('pause-all');\n  }\n  resumeAll() {\n    const updatedFiles = {\n      ...this.getState().files\n    };\n    const inProgressUpdatedFiles = Object.keys(updatedFiles).filter(file => {\n      return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;\n    });\n    inProgressUpdatedFiles.forEach(file => {\n      const updatedFile = {\n        ...updatedFiles[file],\n        isPaused: false,\n        error: null\n      };\n      updatedFiles[file] = updatedFile;\n    });\n    this.setState({\n      files: updatedFiles\n    });\n    this.emit('resume-all');\n  }\n  retryAll() {\n    const updatedFiles = {\n      ...this.getState().files\n    };\n    const filesToRetry = Object.keys(updatedFiles).filter(file => {\n      return updatedFiles[file].error;\n    });\n    filesToRetry.forEach(file => {\n      const updatedFile = {\n        ...updatedFiles[file],\n        isPaused: false,\n        error: null\n      };\n      updatedFiles[file] = updatedFile;\n    });\n    this.setState({\n      files: updatedFiles,\n      error: null\n    });\n    this.emit('retry-all', filesToRetry);\n    if (filesToRetry.length === 0) {\n      return Promise.resolve({\n        successful: [],\n        failed: []\n      });\n    }\n    const uploadID = _classPrivateFieldLooseBase(this, _createUpload)[_createUpload](filesToRetry, {\n      forceAllowNewUpload: true // create new upload even if allowNewUpload: false\n    });\n    return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);\n  }\n  cancelAll(_temp) {\n    let {\n      reason = 'user'\n    } = _temp === void 0 ? {} : _temp;\n    this.emit('cancel-all', {\n      reason\n    });\n\n    // Only remove existing uploads if user is canceling\n    if (reason === 'user') {\n      const {\n        files\n      } = this.getState();\n      const fileIDs = Object.keys(files);\n      if (fileIDs.length) {\n        this.removeFiles(fileIDs, 'cancel-all');\n      }\n      this.setState(defaultUploadState);\n      // todo should we call this.emit('reset-progress') like we do for resetProgress?\n    }\n  }\n  retryUpload(fileID) {\n    this.setFileState(fileID, {\n      error: null,\n      isPaused: false\n    });\n    this.emit('upload-retry', fileID);\n    const uploadID = _classPrivateFieldLooseBase(this, _createUpload)[_createUpload]([fileID], {\n      forceAllowNewUpload: true // create new upload even if allowNewUpload: false\n    });\n    return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);\n  }\n  logout() {\n    this.iteratePlugins(plugin => {\n      var _provider;\n      ;\n      (_provider = plugin.provider) == null || _provider.logout == null || _provider.logout();\n    });\n  }\n  calculateTotalProgress() {\n    // calculate total progress, using the number of files currently uploading,\n    // multiplied by 100 and the summ of individual progress of each file\n    const files = this.getFiles();\n    const inProgress = files.filter(file => {\n      return file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess;\n    });\n    if (inProgress.length === 0) {\n      this.emit('progress', 0);\n      this.setState({\n        totalProgress: 0\n      });\n      return;\n    }\n    const sizedFiles = inProgress.filter(file => file.progress.bytesTotal != null);\n    const unsizedFiles = inProgress.filter(file => file.progress.bytesTotal == null);\n    if (sizedFiles.length === 0) {\n      const progressMax = inProgress.length * 100;\n      const currentProgress = unsizedFiles.reduce((acc, file) => {\n        return acc + file.progress.percentage;\n      }, 0);\n      const totalProgress = Math.round(currentProgress / progressMax * 100);\n      this.setState({\n        totalProgress\n      });\n      return;\n    }\n    let totalSize = sizedFiles.reduce((acc, file) => {\n      var _file$progress$bytesT;\n      return acc + ((_file$progress$bytesT = file.progress.bytesTotal) != null ? _file$progress$bytesT : 0);\n    }, 0);\n    const averageSize = totalSize / sizedFiles.length;\n    totalSize += averageSize * unsizedFiles.length;\n    let uploadedSize = 0;\n    sizedFiles.forEach(file => {\n      uploadedSize += file.progress.bytesUploaded;\n    });\n    unsizedFiles.forEach(file => {\n      uploadedSize += averageSize * (file.progress.percentage || 0) / 100;\n    });\n    let totalProgress = totalSize === 0 ? 0 : Math.round(uploadedSize / totalSize * 100);\n\n    // hot fix, because:\n    // uploadedSize ended up larger than totalSize, resulting in 1325% total\n    if (totalProgress > 100) {\n      totalProgress = 100;\n    }\n    this.setState({\n      totalProgress\n    });\n    this.emit('progress', totalProgress);\n  }\n  updateOnlineStatus() {\n    var _window$navigator$onL;\n    const online = (_window$navigator$onL = window.navigator.onLine) != null ? _window$navigator$onL : true;\n    if (!online) {\n      this.emit('is-offline');\n      this.info(this.i18n('noInternetConnection'), 'error', 0);\n      this.wasOffline = true;\n    } else {\n      this.emit('is-online');\n      if (this.wasOffline) {\n        this.emit('back-online');\n        this.info(this.i18n('connectedToInternet'), 'success', 3000);\n        this.wasOffline = false;\n      }\n    }\n  }\n  getID() {\n    return this.opts.id;\n  }\n\n  /**\n   * Registers a plugin with Core.\n   */\n  use(Plugin, opts) {\n    if (typeof Plugin !== 'function') {\n      const msg = `Expected a plugin class, but got ${Plugin === null ? 'null' : typeof Plugin}.` + ' Please verify that the plugin was imported and spelled correctly.';\n      throw new TypeError(msg);\n    }\n\n    // Instantiate\n    const plugin = new Plugin(this, opts);\n    const pluginId = plugin.id;\n    if (!pluginId) {\n      throw new Error('Your plugin must have an id');\n    }\n    if (!plugin.type) {\n      throw new Error('Your plugin must have a type');\n    }\n    const existsPluginAlready = this.getPlugin(pluginId);\n    if (existsPluginAlready) {\n      const msg = `Already found a plugin named '${existsPluginAlready.id}'. ` + `Tried to use: '${pluginId}'.\\n` + 'Uppy plugins must have unique `id` options. See https://uppy.io/docs/plugins/#id.';\n      throw new Error(msg);\n    }\n\n    // @ts-expect-error does exist\n    if (Plugin.VERSION) {\n      // @ts-expect-error does exist\n      this.log(`Using ${pluginId} v${Plugin.VERSION}`);\n    }\n    if (plugin.type in _classPrivateFieldLooseBase(this, _plugins)[_plugins]) {\n      _classPrivateFieldLooseBase(this, _plugins)[_plugins][plugin.type].push(plugin);\n    } else {\n      _classPrivateFieldLooseBase(this, _plugins)[_plugins][plugin.type] = [plugin];\n    }\n    plugin.install();\n    this.emit('plugin-added', plugin);\n    return this;\n  }\n\n  /**\n   * Find one Plugin by name.\n   */\n  getPlugin(id) {\n    for (const plugins of Object.values(_classPrivateFieldLooseBase(this, _plugins)[_plugins])) {\n      const foundPlugin = plugins.find(plugin => plugin.id === id);\n      if (foundPlugin != null) return foundPlugin;\n    }\n    return undefined;\n  }\n  [_Symbol$for](type) {\n    return _classPrivateFieldLooseBase(this, _plugins)[_plugins][type];\n  }\n\n  /**\n   * Iterate through all `use`d plugins.\n   *\n   */\n  iteratePlugins(method) {\n    Object.values(_classPrivateFieldLooseBase(this, _plugins)[_plugins]).flat(1).forEach(method);\n  }\n\n  /**\n   * Uninstall and remove a plugin.\n   *\n   * @param {object} instance The plugin instance to remove.\n   */\n  removePlugin(instance) {\n    this.log(`Removing plugin ${instance.id}`);\n    this.emit('plugin-remove', instance);\n    if (instance.uninstall) {\n      instance.uninstall();\n    }\n    const list = _classPrivateFieldLooseBase(this, _plugins)[_plugins][instance.type];\n    // list.indexOf failed here, because Vue3 converted the plugin instance\n    // to a Proxy object, which failed the strict comparison test:\n    // obj !== objProxy\n    const index = list.findIndex(item => item.id === instance.id);\n    if (index !== -1) {\n      list.splice(index, 1);\n    }\n    const state = this.getState();\n    const updatedState = {\n      plugins: {\n        ...state.plugins,\n        [instance.id]: undefined\n      }\n    };\n    this.setState(updatedState);\n  }\n\n  /**\n   * Uninstall all plugins and close down this Uppy instance.\n   */\n  // @todo next major: rename to `destroy`.\n  // Cancel local uploads, cancel remote uploads, DON'T cancel assemblies\n  // document that if you do want to cancel assemblies, you need to call smth manually.\n  // Potentially remove reason, as it’s confusing, just come up with a default behaviour.\n  close(_temp2) {\n    let {\n      reason\n    } = _temp2 === void 0 ? {} : _temp2;\n    this.log(`Closing Uppy instance ${this.opts.id}: removing all files and uninstalling plugins`);\n    this.cancelAll({\n      reason\n    });\n    _classPrivateFieldLooseBase(this, _storeUnsubscribe)[_storeUnsubscribe]();\n    this.iteratePlugins(plugin => {\n      this.removePlugin(plugin);\n    });\n    if (typeof window !== 'undefined' && window.removeEventListener) {\n      window.removeEventListener('online', _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);\n      window.removeEventListener('offline', _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);\n    }\n  }\n  hideInfo() {\n    const {\n      info\n    } = this.getState();\n    this.setState({\n      info: info.slice(1)\n    });\n    this.emit('info-hidden');\n  }\n\n  /**\n   * Set info message in `state.info`, so that UI plugins like `Informer`\n   * can display the message.\n   */\n  info(message, type, duration) {\n    if (type === void 0) {\n      type = 'info';\n    }\n    if (duration === void 0) {\n      duration = 3000;\n    }\n    const isComplexMessage = typeof message === 'object';\n    this.setState({\n      info: [...this.getState().info, {\n        type,\n        message: isComplexMessage ? message.message : message,\n        details: isComplexMessage ? message.details : null\n      }]\n    });\n    setTimeout(() => this.hideInfo(), duration);\n    this.emit('info-visible');\n  }\n\n  /**\n   * Passes messages to a function, provided in `opts.logger`.\n   * If `opts.logger: Uppy.debugLogger` or `opts.debug: true`, logs to the browser console.\n   */\n  log(message, type) {\n    const {\n      logger\n    } = this.opts;\n    switch (type) {\n      case 'error':\n        logger.error(message);\n        break;\n      case 'warning':\n        logger.warn(message);\n        break;\n      default:\n        logger.debug(message);\n        break;\n    }\n  }\n  registerRequestClient(id, client) {\n    _classPrivateFieldLooseBase(this, _requestClientById)[_requestClientById].set(id, client);\n  }\n\n  /** @protected */\n  getRequestClientForFile(file) {\n    if (!file.remote) throw new Error(`Tried to get RequestClient for a non-remote file ${file.id}`);\n    const requestClient = _classPrivateFieldLooseBase(this, _requestClientById)[_requestClientById].get(file.remote.requestClientId);\n    if (requestClient == null) throw new Error(`requestClientId \"${file.remote.requestClientId}\" not registered for file \"${file.id}\"`);\n    return requestClient;\n  }\n\n  /**\n   * Restore an upload by its ID.\n   */\n  restore(uploadID) {\n    this.log(`Core: attempting to restore upload \"${uploadID}\"`);\n    if (!this.getState().currentUploads[uploadID]) {\n      _classPrivateFieldLooseBase(this, _removeUpload)[_removeUpload](uploadID);\n      return Promise.reject(new Error('Nonexistent upload'));\n    }\n    return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);\n  }\n  [_Symbol$for2]() {\n    // @ts-expect-error https://github.com/microsoft/TypeScript/issues/47595\n    return _classPrivateFieldLooseBase(this, _createUpload)[_createUpload](...arguments);\n  }\n  /**\n   * Add data to an upload's result object.\n   */\n  addResultData(uploadID, data) {\n    if (!_classPrivateFieldLooseBase(this, _getUpload)[_getUpload](uploadID)) {\n      this.log(`Not setting result for an upload that has been removed: ${uploadID}`);\n      return;\n    }\n    const {\n      currentUploads\n    } = this.getState();\n    const currentUpload = {\n      ...currentUploads[uploadID],\n      result: {\n        ...currentUploads[uploadID].result,\n        ...data\n      }\n    };\n    this.setState({\n      currentUploads: {\n        ...currentUploads,\n        [uploadID]: currentUpload\n      }\n    });\n  }\n  /**\n   * Start an upload for all the files that are not currently being uploaded.\n   */\n  upload() {\n    var _classPrivateFieldLoo;\n    if (!((_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _plugins)[_plugins]['uploader']) != null && _classPrivateFieldLoo.length)) {\n      this.log('No uploader type plugins are used', 'warning');\n    }\n    let {\n      files\n    } = this.getState();\n    const onBeforeUploadResult = this.opts.onBeforeUpload(files);\n    if (onBeforeUploadResult === false) {\n      return Promise.reject(new Error('Not starting the upload because onBeforeUpload returned false'));\n    }\n    if (onBeforeUploadResult && typeof onBeforeUploadResult === 'object') {\n      files = onBeforeUploadResult;\n      // Updating files in state, because uploader plugins receive file IDs,\n      // and then fetch the actual file object from state\n      this.setState({\n        files\n      });\n    }\n    return Promise.resolve().then(() => _classPrivateFieldLooseBase(this, _restricter)[_restricter].validateMinNumberOfFiles(files)).catch(err => {\n      _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit]([err]);\n      throw err;\n    }).then(() => {\n      if (!_classPrivateFieldLooseBase(this, _checkRequiredMetaFields)[_checkRequiredMetaFields](files)) {\n        throw new RestrictionError(this.i18n('missingRequiredMetaField'));\n      }\n    }).catch(err => {\n      // Doing this in a separate catch because we already emited and logged\n      // all the errors in `checkRequiredMetaFields` so we only throw a generic\n      // missing fields error here.\n      throw err;\n    }).then(() => {\n      const {\n        currentUploads\n      } = this.getState();\n      // get a list of files that are currently assigned to uploads\n      const currentlyUploadingFiles = Object.values(currentUploads).flatMap(curr => curr.fileIDs);\n      const waitingFileIDs = [];\n      Object.keys(files).forEach(fileID => {\n        const file = this.getFile(fileID);\n        // if the file hasn't started uploading and hasn't already been assigned to an upload..\n        if (!file.progress.uploadStarted && currentlyUploadingFiles.indexOf(fileID) === -1) {\n          waitingFileIDs.push(file.id);\n        }\n      });\n      const uploadID = _classPrivateFieldLooseBase(this, _createUpload)[_createUpload](waitingFileIDs);\n      return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);\n    }).catch(err => {\n      this.emit('error', err);\n      this.log(err, 'error');\n      throw err;\n    });\n  }\n}\nfunction _informAndEmit2(errors) {\n  for (const error of errors) {\n    if (error.isRestriction) {\n      this.emit('restriction-failed', error.file, error);\n    } else {\n      this.emit('error', error, error.file);\n    }\n    this.log(error, 'warning');\n  }\n  const userFacingErrors = errors.filter(error => error.isUserFacing);\n\n  // don't flood the user: only show the first 4 toasts\n  const maxNumToShow = 4;\n  const firstErrors = userFacingErrors.slice(0, maxNumToShow);\n  const additionalErrors = userFacingErrors.slice(maxNumToShow);\n  firstErrors.forEach(_ref2 => {\n    let {\n      message,\n      details = ''\n    } = _ref2;\n    this.info({\n      message,\n      details\n    }, 'error', this.opts.infoTimeout);\n  });\n  if (additionalErrors.length > 0) {\n    this.info({\n      message: this.i18n('additionalRestrictionsFailed', {\n        count: additionalErrors.length\n      })\n    });\n  }\n}\nfunction _checkRequiredMetaFieldsOnFile2(file) {\n  const {\n    missingFields,\n    error\n  } = _classPrivateFieldLooseBase(this, _restricter)[_restricter].getMissingRequiredMetaFields(file);\n  if (missingFields.length > 0) {\n    this.setFileState(file.id, {\n      missingRequiredMetaFields: missingFields\n    });\n    this.log(error.message);\n    this.emit('restriction-failed', file, error);\n    return false;\n  }\n  return true;\n}\nfunction _checkRequiredMetaFields2(files) {\n  let success = true;\n  for (const file of Object.values(files)) {\n    if (!_classPrivateFieldLooseBase(this, _checkRequiredMetaFieldsOnFile)[_checkRequiredMetaFieldsOnFile](file)) {\n      success = false;\n    }\n  }\n  return success;\n}\nfunction _assertNewUploadAllowed2(file) {\n  const {\n    allowNewUpload\n  } = this.getState();\n  if (allowNewUpload === false) {\n    const error = new RestrictionError(this.i18n('noMoreFilesAllowed'), {\n      file\n    });\n    _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit]([error]);\n    throw error;\n  }\n}\nfunction _transformFile2(fileDescriptorOrFile) {\n  // Uppy expects files in { name, type, size, data } format.\n  // If the actual File object is passed from input[type=file] or drag-drop,\n  // we normalize it to match Uppy file object\n  const file = fileDescriptorOrFile instanceof File ? {\n    name: fileDescriptorOrFile.name,\n    type: fileDescriptorOrFile.type,\n    size: fileDescriptorOrFile.size,\n    data: fileDescriptorOrFile\n  } : fileDescriptorOrFile;\n  const fileType = getFileType(file);\n  const fileName = getFileName(fileType, file);\n  const fileExtension = getFileNameAndExtension(fileName).extension;\n  const id = getSafeFileId(file, this.getID());\n  const meta = file.meta || {};\n  meta.name = fileName;\n  meta.type = fileType;\n\n  // `null` means the size is unknown.\n  const size = Number.isFinite(file.data.size) ? file.data.size : null;\n  return {\n    source: file.source || '',\n    id,\n    name: fileName,\n    extension: fileExtension || '',\n    meta: {\n      ...this.getState().meta,\n      ...meta\n    },\n    type: fileType,\n    data: file.data,\n    progress: {\n      percentage: 0,\n      bytesUploaded: 0,\n      bytesTotal: size,\n      uploadComplete: false,\n      uploadStarted: null\n    },\n    size,\n    isGhost: false,\n    isRemote: file.isRemote || false,\n    // TODO: this should not be a string\n    // @ts-expect-error wrong\n    remote: file.remote || '',\n    preview: file.preview\n  };\n}\nfunction _startIfAutoProceed2() {\n  if (this.opts.autoProceed && !this.scheduledAutoProceed) {\n    this.scheduledAutoProceed = setTimeout(() => {\n      this.scheduledAutoProceed = null;\n      this.upload().catch(err => {\n        if (!err.isRestriction) {\n          this.log(err.stack || err.message || err);\n        }\n      });\n    }, 4);\n  }\n}\nfunction _checkAndUpdateFileState2(filesToAdd) {\n  const {\n    files: existingFiles\n  } = this.getState();\n\n  // create a copy of the files object only once\n  const nextFilesState = {\n    ...existingFiles\n  };\n  const validFilesToAdd = [];\n  const errors = [];\n  for (const fileToAdd of filesToAdd) {\n    try {\n      var _existingFiles$newFil;\n      let newFile = _classPrivateFieldLooseBase(this, _transformFile)[_transformFile](fileToAdd);\n\n      // If a file has been recovered (Golden Retriever), but we were unable to recover its data (probably too large),\n      // users are asked to re-select these half-recovered files and then this method will be called again.\n      // In order to keep the progress, meta and everything else, we keep the existing file,\n      // but we replace `data`, and we remove `isGhost`, because the file is no longer a ghost now\n      const isGhost = (_existingFiles$newFil = existingFiles[newFile.id]) == null ? void 0 : _existingFiles$newFil.isGhost;\n      if (isGhost) {\n        const existingFileState = existingFiles[newFile.id];\n        newFile = {\n          ...existingFileState,\n          isGhost: false,\n          data: fileToAdd.data\n        };\n        this.log(`Replaced the blob in the restored ghost file: ${newFile.name}, ${newFile.id}`);\n      }\n      const onBeforeFileAddedResult = this.opts.onBeforeFileAdded(newFile, nextFilesState);\n      if (!onBeforeFileAddedResult && this.checkIfFileAlreadyExists(newFile.id)) {\n        throw new RestrictionError(this.i18n('noDuplicates', {\n          fileName: newFile.name\n        }), {\n          file: fileToAdd\n        });\n      }\n\n      // Pass through reselected files from Golden Retriever\n      if (onBeforeFileAddedResult === false && !isGhost) {\n        // Don’t show UI info for this error, as it should be done by the developer\n        throw new RestrictionError('Cannot add the file because onBeforeFileAdded returned false.', {\n          isUserFacing: false,\n          file: fileToAdd\n        });\n      } else if (typeof onBeforeFileAddedResult === 'object' && onBeforeFileAddedResult !== null) {\n        newFile = onBeforeFileAddedResult;\n      }\n      _classPrivateFieldLooseBase(this, _restricter)[_restricter].validateSingleFile(newFile);\n\n      // need to add it to the new local state immediately, so we can use the state to validate the next files too\n      nextFilesState[newFile.id] = newFile;\n      validFilesToAdd.push(newFile);\n    } catch (err) {\n      errors.push(err);\n    }\n  }\n  try {\n    // need to run this separately because it's much more slow, so if we run it inside the for-loop it will be very slow\n    // when many files are added\n    _classPrivateFieldLooseBase(this, _restricter)[_restricter].validateAggregateRestrictions(Object.values(existingFiles), validFilesToAdd);\n  } catch (err) {\n    errors.push(err);\n\n    // If we have any aggregate error, don't allow adding this batch\n    return {\n      nextFilesState: existingFiles,\n      validFilesToAdd: [],\n      errors\n    };\n  }\n  return {\n    nextFilesState,\n    validFilesToAdd,\n    errors\n  };\n}\nfunction _addListeners2() {\n  // Type inference only works for inline functions so we have to type it again\n  const errorHandler = (error, file, response) => {\n    let errorMsg = error.message || 'Unknown error';\n    if (error.details) {\n      errorMsg += ` ${error.details}`;\n    }\n    this.setState({\n      error: errorMsg\n    });\n    if (file != null && file.id in this.getState().files) {\n      this.setFileState(file.id, {\n        error: errorMsg,\n        response\n      });\n    }\n  };\n  this.on('error', errorHandler);\n  this.on('upload-error', (file, error, response) => {\n    errorHandler(error, file, response);\n    if (typeof error === 'object' && error.message) {\n      var _file$name;\n      this.log(error.message, 'error');\n      const newError = new Error(this.i18n('failedToUpload', {\n        file: (_file$name = file == null ? void 0 : file.name) != null ? _file$name : ''\n      })); // we may want a new custom error here\n      newError.isUserFacing = true; // todo maybe don't do this with all errors?\n      newError.details = error.message;\n      if (error.details) {\n        newError.details += ` ${error.details}`;\n      }\n      _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit]([newError]);\n    } else {\n      _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit]([error]);\n    }\n  });\n  let uploadStalledWarningRecentlyEmitted = null;\n  this.on('upload-stalled', (error, files) => {\n    const {\n      message\n    } = error;\n    const details = files.map(file => file.meta.name).join(', ');\n    if (!uploadStalledWarningRecentlyEmitted) {\n      this.info({\n        message,\n        details\n      }, 'warning', this.opts.infoTimeout);\n      uploadStalledWarningRecentlyEmitted = setTimeout(() => {\n        uploadStalledWarningRecentlyEmitted = null;\n      }, this.opts.infoTimeout);\n    }\n    this.log(`${message} ${details}`.trim(), 'warning');\n  });\n  this.on('upload', () => {\n    this.setState({\n      error: null\n    });\n  });\n  const onUploadStarted = files => {\n    const filesFiltered = files.filter(file => {\n      const exists = file != null && this.getFile(file.id);\n      if (!exists) this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);\n      return exists;\n    });\n    const filesState = Object.fromEntries(filesFiltered.map(file => [file.id, {\n      progress: {\n        uploadStarted: Date.now(),\n        uploadComplete: false,\n        percentage: 0,\n        bytesUploaded: 0,\n        bytesTotal: file.size\n      }\n    }]));\n    this.patchFilesState(filesState);\n  };\n  this.on('upload-start', files => {\n    files.forEach(file => {\n      // todo backward compat, remove this event in a next major\n      this.emit('upload-started', file);\n    });\n    onUploadStarted(files);\n  });\n  this.on('upload-progress', this.calculateProgress);\n  this.on('upload-success', (file, uploadResp) => {\n    if (file == null || !this.getFile(file.id)) {\n      this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);\n      return;\n    }\n    const currentProgress = this.getFile(file.id).progress;\n    this.setFileState(file.id, {\n      progress: {\n        ...currentProgress,\n        postprocess: _classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors].size > 0 ? {\n          mode: 'indeterminate'\n        } : undefined,\n        uploadComplete: true,\n        percentage: 100,\n        bytesUploaded: currentProgress.bytesTotal\n      },\n      response: uploadResp,\n      uploadURL: uploadResp.uploadURL,\n      isPaused: false\n    });\n\n    // Remote providers sometimes don't tell us the file size,\n    // but we can know how many bytes we uploaded once the upload is complete.\n    if (file.size == null) {\n      this.setFileState(file.id, {\n        size: uploadResp.bytesUploaded || currentProgress.bytesTotal\n      });\n    }\n    this.calculateTotalProgress();\n  });\n  this.on('preprocess-progress', (file, progress) => {\n    if (file == null || !this.getFile(file.id)) {\n      this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);\n      return;\n    }\n    this.setFileState(file.id, {\n      progress: {\n        ...this.getFile(file.id).progress,\n        preprocess: progress\n      }\n    });\n  });\n  this.on('preprocess-complete', file => {\n    if (file == null || !this.getFile(file.id)) {\n      this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);\n      return;\n    }\n    const files = {\n      ...this.getState().files\n    };\n    files[file.id] = {\n      ...files[file.id],\n      progress: {\n        ...files[file.id].progress\n      }\n    };\n    delete files[file.id].progress.preprocess;\n    this.setState({\n      files\n    });\n  });\n  this.on('postprocess-progress', (file, progress) => {\n    if (file == null || !this.getFile(file.id)) {\n      this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);\n      return;\n    }\n    this.setFileState(file.id, {\n      progress: {\n        ...this.getState().files[file.id].progress,\n        postprocess: progress\n      }\n    });\n  });\n  this.on('postprocess-complete', file => {\n    if (file == null || !this.getFile(file.id)) {\n      this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);\n      return;\n    }\n    const files = {\n      ...this.getState().files\n    };\n    files[file.id] = {\n      ...files[file.id],\n      progress: {\n        ...files[file.id].progress\n      }\n    };\n    delete files[file.id].progress.postprocess;\n    this.setState({\n      files\n    });\n  });\n  this.on('restored', () => {\n    // Files may have changed--ensure progress is still accurate.\n    this.calculateTotalProgress();\n  });\n\n  // @ts-expect-error should fix itself when dashboard it typed (also this doesn't belong here)\n  this.on('dashboard:file-edit-complete', file => {\n    if (file) {\n      _classPrivateFieldLooseBase(this, _checkRequiredMetaFieldsOnFile)[_checkRequiredMetaFieldsOnFile](file);\n    }\n  });\n\n  // show informer if offline\n  if (typeof window !== 'undefined' && window.addEventListener) {\n    window.addEventListener('online', _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);\n    window.addEventListener('offline', _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);\n    setTimeout(_classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus], 3000);\n  }\n}\nfunction _createUpload2(fileIDs, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  // uppy.retryAll sets this to true — when retrying we want to ignore `allowNewUpload: false`\n  const {\n    forceAllowNewUpload = false\n  } = opts;\n  const {\n    allowNewUpload,\n    currentUploads\n  } = this.getState();\n  if (!allowNewUpload && !forceAllowNewUpload) {\n    throw new Error('Cannot create a new upload: already uploading.');\n  }\n  const uploadID = nanoid();\n  this.emit('upload', {\n    id: uploadID,\n    fileIDs\n  });\n  this.setState({\n    allowNewUpload: this.opts.allowMultipleUploadBatches !== false && this.opts.allowMultipleUploads !== false,\n    currentUploads: {\n      ...currentUploads,\n      [uploadID]: {\n        fileIDs,\n        step: 0,\n        result: {}\n      }\n    }\n  });\n  return uploadID;\n}\nfunction _getUpload2(uploadID) {\n  const {\n    currentUploads\n  } = this.getState();\n  return currentUploads[uploadID];\n}\nfunction _removeUpload2(uploadID) {\n  const currentUploads = {\n    ...this.getState().currentUploads\n  };\n  delete currentUploads[uploadID];\n  this.setState({\n    currentUploads\n  });\n}\nasync function _runUpload2(uploadID) {\n  const getCurrentUpload = () => {\n    const {\n      currentUploads\n    } = this.getState();\n    return currentUploads[uploadID];\n  };\n  let currentUpload = getCurrentUpload();\n  const steps = [..._classPrivateFieldLooseBase(this, _preProcessors)[_preProcessors], ..._classPrivateFieldLooseBase(this, _uploaders)[_uploaders], ..._classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors]];\n  try {\n    for (let step = currentUpload.step || 0; step < steps.length; step++) {\n      if (!currentUpload) {\n        break;\n      }\n      const fn = steps[step];\n      this.setState({\n        currentUploads: {\n          ...this.getState().currentUploads,\n          [uploadID]: {\n            ...currentUpload,\n            step\n          }\n        }\n      });\n      const {\n        fileIDs\n      } = currentUpload;\n\n      // TODO give this the `updatedUpload` object as its only parameter maybe?\n      // Otherwise when more metadata may be added to the upload this would keep getting more parameters\n      await fn(fileIDs, uploadID);\n\n      // Update currentUpload value in case it was modified asynchronously.\n      currentUpload = getCurrentUpload();\n    }\n  } catch (err) {\n    _classPrivateFieldLooseBase(this, _removeUpload)[_removeUpload](uploadID);\n    throw err;\n  }\n\n  // Set result data.\n  if (currentUpload) {\n    // Mark postprocessing step as complete if necessary; this addresses a case where we might get\n    // stuck in the postprocessing UI while the upload is fully complete.\n    // If the postprocessing steps do not do any work, they may not emit postprocessing events at\n    // all, and never mark the postprocessing as complete. This is fine on its own but we\n    // introduced code in the @uppy/core upload-success handler to prepare postprocessing progress\n    // state if any postprocessors are registered. That is to avoid a \"flash of completed state\"\n    // before the postprocessing plugins can emit events.\n    //\n    // So, just in case an upload with postprocessing plugins *has* completed *without* emitting\n    // postprocessing completion, we do it instead.\n    currentUpload.fileIDs.forEach(fileID => {\n      const file = this.getFile(fileID);\n      if (file && file.progress.postprocess) {\n        this.emit('postprocess-complete', file);\n      }\n    });\n    const files = currentUpload.fileIDs.map(fileID => this.getFile(fileID));\n    const successful = files.filter(file => !file.error);\n    const failed = files.filter(file => file.error);\n    this.addResultData(uploadID, {\n      successful,\n      failed,\n      uploadID\n    });\n\n    // Update currentUpload value in case it was modified asynchronously.\n    currentUpload = getCurrentUpload();\n  }\n  // Emit completion events.\n  // This is in a separate function so that the `currentUploads` variable\n  // always refers to the latest state. In the handler right above it refers\n  // to an outdated object without the `.result` property.\n  let result;\n  if (currentUpload) {\n    result = currentUpload.result;\n    this.emit('complete', result);\n    _classPrivateFieldLooseBase(this, _removeUpload)[_removeUpload](uploadID);\n  }\n  if (result == null) {\n    this.log(`Not setting result for an upload that has been removed: ${uploadID}`);\n  }\n  return result;\n}\nUppy.VERSION = packageJson.version;\nexport default Uppy;","map":{"version":3,"names":["_Symbol$for","_Symbol$for2","_classPrivateFieldLooseBase","receiver","privateKey","Object","prototype","hasOwnProperty","call","TypeError","id","_classPrivateFieldLooseKey","name","Translator","ee","nanoid","throttle","DefaultStore","getFileType","getFileNameAndExtension","getSafeFileId","supportsUploadProgress","getFileName","justErrorsLogger","debugLogger","Restricter","defaultOptions","defaultRestrictionOptions","RestrictionError","packageJson","locale","defaultUploadState","totalProgress","allowNewUpload","error","recoveredState","_plugins","_restricter","_storeUnsubscribe","_emitter","_preProcessors","_uploaders","_postProcessors","_informAndEmit","_checkRequiredMetaFieldsOnFile","_checkRequiredMetaFields","_assertNewUploadAllowed","_transformFile","_startIfAutoProceed","_checkAndUpdateFileState","_addListeners","_updateOnlineStatus","_requestClientById","_createUpload","_getUpload","_removeUpload","_runUpload","Symbol","for","Uppy","constructor","_opts","defineProperty","value","_runUpload2","_removeUpload2","_getUpload2","_createUpload2","_addListeners2","_checkAndUpdateFileState2","_startIfAutoProceed2","_transformFile2","_assertNewUploadAllowed2","_checkRequiredMetaFields2","_checkRequiredMetaFieldsOnFile2","_informAndEmit2","writable","create","Set","scheduledAutoProceed","wasOffline","calculateProgress","file","data","fileInState","getFile","log","progress","percentage","canHavePercentage","Number","isFinite","bytesTotal","setFileState","bytesUploaded","Math","round","calculateTotalProgress","leading","trailing","updateOnlineStatus","bind","Map","defaultLocale","autoProceed","allowMultipleUploadBatches","debug","restrictions","meta","onBeforeFileAdded","files","hasOwn","onBeforeUpload","store","logger","infoTimeout","merged","opts","VERSION","i18nInit","setState","plugins","currentUploads","capabilities","uploadProgress","individualCancellation","resumableUploads","info","i18n","subscribe","prevState","nextState","patch","emit","updateAll","window","event","_len","arguments","length","args","Array","_key","on","callback","once","off","state","iteratePlugins","plugin","update","getState","patchFilesState","filesWithNewState","existingFilesState","fromEntries","entries","map","_ref","fileID","newFileState","Error","onMissingKey","key","translator","translate","i18nArray","translateArray","setOptions","newOpts","setMeta","undefined","resetProgress","defaultProgress","uploadComplete","uploadStarted","updatedFiles","keys","forEach","clearUploadedFiles","addPreProcessor","fn","add","removePreProcessor","delete","addPostProcessor","removePostProcessor","addUploader","removeUploader","updatedMeta","setFileMeta","newMeta","getFiles","values","getFilesByIds","ids","getObjectOfFilesPerState","filesObject","inProgressFiles","newFiles","startedFiles","uploadStartedFiles","pausedFiles","completeFiles","erroredFiles","inProgressNotPausedFiles","processingFiles","push","isPaused","preprocess","postprocess","isUploadStarted","isAllComplete","isAllErrored","isAllPaused","isUploadInProgress","isSomeGhost","some","isGhost","validateRestrictions","validate","err","checkIfFileAlreadyExists","addFile","nextFilesState","validFilesToAdd","errors","restrictionErrors","filter","isRestriction","firstValidFileToAdd","type","addFiles","fileDescriptors","nonRestrictionErrors","message","subError","smart_count","details","AggregateError","removeFiles","fileIDs","reason","updatedUploads","removedFiles","fileIsNotRemoved","uploadFileID","uploadID","newFileIDs","stateUpdate","removedFileIDs","join","removeFile","pauseResume","wasPaused","pauseAll","inProgressUpdatedFiles","updatedFile","resumeAll","retryAll","filesToRetry","Promise","resolve","successful","failed","forceAllowNewUpload","cancelAll","_temp","retryUpload","logout","_provider","provider","inProgress","sizedFiles","unsizedFiles","progressMax","currentProgress","reduce","acc","totalSize","_file$progress$bytesT","averageSize","uploadedSize","_window$navigator$onL","online","navigator","onLine","getID","use","Plugin","msg","pluginId","existsPluginAlready","getPlugin","install","foundPlugin","find","method","flat","removePlugin","instance","uninstall","list","index","findIndex","item","splice","updatedState","close","_temp2","removeEventListener","hideInfo","slice","duration","isComplexMessage","setTimeout","warn","registerRequestClient","client","set","getRequestClientForFile","remote","requestClient","get","requestClientId","restore","reject","addResultData","currentUpload","result","upload","_classPrivateFieldLoo","onBeforeUploadResult","then","validateMinNumberOfFiles","catch","currentlyUploadingFiles","flatMap","curr","waitingFileIDs","indexOf","userFacingErrors","isUserFacing","maxNumToShow","firstErrors","additionalErrors","_ref2","count","missingFields","getMissingRequiredMetaFields","missingRequiredMetaFields","success","fileDescriptorOrFile","File","size","fileType","fileName","fileExtension","extension","source","isRemote","preview","stack","filesToAdd","existingFiles","fileToAdd","_existingFiles$newFil","newFile","existingFileState","onBeforeFileAddedResult","validateSingleFile","validateAggregateRestrictions","errorHandler","response","errorMsg","_file$name","newError","uploadStalledWarningRecentlyEmitted","trim","onUploadStarted","filesFiltered","exists","filesState","Date","now","uploadResp","mode","uploadURL","addEventListener","allowMultipleUploads","step","getCurrentUpload","steps","version"],"sources":["/Users/krithin/Desktop/WildHacks2025/frontend/node_modules/@uppy/core/lib/Uppy.js"],"sourcesContent":["let _Symbol$for, _Symbol$for2;\nfunction _classPrivateFieldLooseBase(receiver, privateKey) { if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) { throw new TypeError(\"attempted to use private field on non-instance\"); } return receiver; }\nvar id = 0;\nfunction _classPrivateFieldLooseKey(name) { return \"__private_\" + id++ + \"_\" + name; }\n/* eslint-disable max-classes-per-file */\n/* global AggregateError */\n\nimport Translator from '@uppy/utils/lib/Translator';\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore untyped\nimport ee from 'namespace-emitter';\nimport { nanoid } from 'nanoid/non-secure';\nimport throttle from 'lodash/throttle.js';\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore store-default types not always available on that branch\nimport DefaultStore from '@uppy/store-default';\nimport getFileType from '@uppy/utils/lib/getFileType';\nimport getFileNameAndExtension from '@uppy/utils/lib/getFileNameAndExtension';\nimport { getSafeFileId } from '@uppy/utils/lib/generateFileID';\nimport supportsUploadProgress from \"./supportsUploadProgress.js\";\nimport getFileName from \"./getFileName.js\";\nimport { justErrorsLogger, debugLogger } from \"./loggers.js\";\nimport { Restricter, defaultOptions as defaultRestrictionOptions, RestrictionError } from \"./Restricter.js\";\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore We don't want TS to generate types for the package.json\nconst packageJson = {\n  \"version\": \"3.13.1\"\n};\nimport locale from \"./locale.js\";\n\n/*\n * UnknownProviderPlugin can be any Companion plugin (such as Google Drive).\n * As the plugins are passed around throughout Uppy we need a generic type for this.\n * It may seems like duplication, but this type safe. Changing the type of `storage`\n * will error in the `Provider` class of @uppy/companion-client and vice versa.\n *\n * Note that this is the *plugin* class, not a version of the `Provider` class.\n * `Provider` does operate on Companion plugins with `uppy.getPlugin()`.\n */\n\n/*\n * UnknownSearchProviderPlugin can be any search Companion plugin (such as Unsplash).\n * As the plugins are passed around throughout Uppy we need a generic type for this.\n * It may seems like duplication, but this type safe. Changing the type of `title`\n * will error in the `SearchProvider` class of @uppy/companion-client and vice versa.\n *\n * Note that this is the *plugin* class, not a version of the `SearchProvider` class.\n * `SearchProvider` does operate on Companion plugins with `uppy.getPlugin()`.\n */\n\n// TODO: can we use namespaces in other plugins to populate this?\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\n\n// The user facing type for UppyOptions used in uppy.setOptions()\n\n/** @deprecated */\n\nconst defaultUploadState = {\n  totalProgress: 0,\n  allowNewUpload: true,\n  error: null,\n  recoveredState: null\n};\n\n/**\n * Uppy Core module.\n * Manages plugins, state updates, acts as an event bus,\n * adds/removes files and metadata.\n */\nvar _plugins = /*#__PURE__*/_classPrivateFieldLooseKey(\"plugins\");\nvar _restricter = /*#__PURE__*/_classPrivateFieldLooseKey(\"restricter\");\nvar _storeUnsubscribe = /*#__PURE__*/_classPrivateFieldLooseKey(\"storeUnsubscribe\");\nvar _emitter = /*#__PURE__*/_classPrivateFieldLooseKey(\"emitter\");\nvar _preProcessors = /*#__PURE__*/_classPrivateFieldLooseKey(\"preProcessors\");\nvar _uploaders = /*#__PURE__*/_classPrivateFieldLooseKey(\"uploaders\");\nvar _postProcessors = /*#__PURE__*/_classPrivateFieldLooseKey(\"postProcessors\");\nvar _informAndEmit = /*#__PURE__*/_classPrivateFieldLooseKey(\"informAndEmit\");\nvar _checkRequiredMetaFieldsOnFile = /*#__PURE__*/_classPrivateFieldLooseKey(\"checkRequiredMetaFieldsOnFile\");\nvar _checkRequiredMetaFields = /*#__PURE__*/_classPrivateFieldLooseKey(\"checkRequiredMetaFields\");\nvar _assertNewUploadAllowed = /*#__PURE__*/_classPrivateFieldLooseKey(\"assertNewUploadAllowed\");\nvar _transformFile = /*#__PURE__*/_classPrivateFieldLooseKey(\"transformFile\");\nvar _startIfAutoProceed = /*#__PURE__*/_classPrivateFieldLooseKey(\"startIfAutoProceed\");\nvar _checkAndUpdateFileState = /*#__PURE__*/_classPrivateFieldLooseKey(\"checkAndUpdateFileState\");\nvar _addListeners = /*#__PURE__*/_classPrivateFieldLooseKey(\"addListeners\");\nvar _updateOnlineStatus = /*#__PURE__*/_classPrivateFieldLooseKey(\"updateOnlineStatus\");\nvar _requestClientById = /*#__PURE__*/_classPrivateFieldLooseKey(\"requestClientById\");\nvar _createUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"createUpload\");\nvar _getUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"getUpload\");\nvar _removeUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"removeUpload\");\nvar _runUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"runUpload\");\n_Symbol$for = Symbol.for('uppy test: getPlugins');\n_Symbol$for2 = Symbol.for('uppy test: createUpload');\nexport class Uppy {\n  /**\n   * Instantiate Uppy\n   */\n  constructor(_opts) {\n    /**\n     * Run an upload. This picks up where it left off in case the upload is being restored.\n     */\n    Object.defineProperty(this, _runUpload, {\n      value: _runUpload2\n    });\n    /**\n     * Remove an upload, eg. if it has been canceled or completed.\n     *\n     */\n    Object.defineProperty(this, _removeUpload, {\n      value: _removeUpload2\n    });\n    Object.defineProperty(this, _getUpload, {\n      value: _getUpload2\n    });\n    /**\n     * Create an upload for a bunch of files.\n     *\n     */\n    Object.defineProperty(this, _createUpload, {\n      value: _createUpload2\n    });\n    /**\n     * Registers listeners for all global actions, like:\n     * `error`, `file-removed`, `upload-progress`\n     */\n    Object.defineProperty(this, _addListeners, {\n      value: _addListeners2\n    });\n    Object.defineProperty(this, _checkAndUpdateFileState, {\n      value: _checkAndUpdateFileState2\n    });\n    // Schedule an upload if `autoProceed` is enabled.\n    Object.defineProperty(this, _startIfAutoProceed, {\n      value: _startIfAutoProceed2\n    });\n    /**\n     * Create a file state object based on user-provided `addFile()` options.\n     */\n    Object.defineProperty(this, _transformFile, {\n      value: _transformFile2\n    });\n    Object.defineProperty(this, _assertNewUploadAllowed, {\n      value: _assertNewUploadAllowed2\n    });\n    Object.defineProperty(this, _checkRequiredMetaFields, {\n      value: _checkRequiredMetaFields2\n    });\n    Object.defineProperty(this, _checkRequiredMetaFieldsOnFile, {\n      value: _checkRequiredMetaFieldsOnFile2\n    });\n    Object.defineProperty(this, _informAndEmit, {\n      value: _informAndEmit2\n    });\n    Object.defineProperty(this, _plugins, {\n      writable: true,\n      value: Object.create(null)\n    });\n    Object.defineProperty(this, _restricter, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _storeUnsubscribe, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _emitter, {\n      writable: true,\n      value: ee()\n    });\n    Object.defineProperty(this, _preProcessors, {\n      writable: true,\n      value: new Set()\n    });\n    Object.defineProperty(this, _uploaders, {\n      writable: true,\n      value: new Set()\n    });\n    Object.defineProperty(this, _postProcessors, {\n      writable: true,\n      value: new Set()\n    });\n    this.scheduledAutoProceed = null;\n    this.wasOffline = false;\n    // ___Why throttle at 500ms?\n    //    - We must throttle at >250ms for superfocus in Dashboard to work well\n    //    (because animation takes 0.25s, and we want to wait for all animations to be over before refocusing).\n    //    [Practical Check]: if thottle is at 100ms, then if you are uploading a file,\n    //    and click 'ADD MORE FILES', - focus won't activate in Firefox.\n    //    - We must throttle at around >500ms to avoid performance lags.\n    //    [Practical Check] Firefox, try to upload a big file for a prolonged period of time. Laptop will start to heat up.\n    // todo when uploading multiple files, this will cause problems because they share the same throttle,\n    // meaning some files might never get their progress reported (eaten up by progress events from other files)\n    this.calculateProgress = throttle((file, data) => {\n      const fileInState = this.getFile(file == null ? void 0 : file.id);\n      if (file == null || !fileInState) {\n        this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);\n        return;\n      }\n      if (fileInState.progress.percentage === 100) {\n        this.log(`Not setting progress for a file that has been already uploaded: ${file.id}`);\n        return;\n      }\n\n      // bytesTotal may be null or zero; in that case we can't divide by it\n      const canHavePercentage = Number.isFinite(data.bytesTotal) && data.bytesTotal > 0;\n      this.setFileState(file.id, {\n        progress: {\n          ...fileInState.progress,\n          bytesUploaded: data.bytesUploaded,\n          bytesTotal: data.bytesTotal,\n          percentage: canHavePercentage ? Math.round(data.bytesUploaded / data.bytesTotal * 100) : 0\n        }\n      });\n      this.calculateTotalProgress();\n    }, 500, {\n      leading: true,\n      trailing: true\n    });\n    Object.defineProperty(this, _updateOnlineStatus, {\n      writable: true,\n      value: this.updateOnlineStatus.bind(this)\n    });\n    // We need to store request clients by a unique ID, so we can share RequestClient instances across files\n    // this allows us to do rate limiting and synchronous operations like refreshing provider tokens\n    // example: refreshing tokens: if each file has their own requestclient,\n    // we don't have any way to synchronize all requests in order to\n    // - block all requests\n    // - refresh the token\n    // - unblock all requests and allow them to run with a the new access token\n    // back when we had a requestclient per file, once an access token expired,\n    // all 6 files would go ahead and refresh the token at the same time\n    // (calling /refresh-token up to 6 times), which will probably fail for some providers\n    Object.defineProperty(this, _requestClientById, {\n      writable: true,\n      value: new Map()\n    });\n    this.defaultLocale = locale;\n    const defaultOptions = {\n      id: 'uppy',\n      autoProceed: false,\n      allowMultipleUploadBatches: true,\n      debug: false,\n      restrictions: defaultRestrictionOptions,\n      meta: {},\n      onBeforeFileAdded: (file, files) => !Object.hasOwn(files, file.id),\n      onBeforeUpload: files => files,\n      store: new DefaultStore(),\n      logger: justErrorsLogger,\n      infoTimeout: 5000\n    };\n    const merged = {\n      ...defaultOptions,\n      ..._opts\n    };\n    // Merge default options with the ones set by user,\n    // making sure to merge restrictions too\n    this.opts = {\n      ...merged,\n      restrictions: {\n        ...defaultOptions.restrictions,\n        ...(_opts && _opts.restrictions)\n      }\n    };\n\n    // Support debug: true for backwards-compatability, unless logger is set in opts\n    // opts instead of this.opts to avoid comparing objects — we set logger: justErrorsLogger in defaultOptions\n    if (_opts && _opts.logger && _opts.debug) {\n      this.log('You are using a custom `logger`, but also set `debug: true`, which uses built-in logger to output logs to console. Ignoring `debug: true` and using your custom `logger`.', 'warning');\n    } else if (_opts && _opts.debug) {\n      this.opts.logger = debugLogger;\n    }\n    this.log(`Using Core v${Uppy.VERSION}`);\n    this.i18nInit();\n    this.store = this.opts.store;\n    this.setState({\n      ...defaultUploadState,\n      plugins: {},\n      files: {},\n      currentUploads: {},\n      capabilities: {\n        uploadProgress: supportsUploadProgress(),\n        individualCancellation: true,\n        resumableUploads: false\n      },\n      meta: {\n        ...this.opts.meta\n      },\n      info: []\n    });\n    _classPrivateFieldLooseBase(this, _restricter)[_restricter] = new Restricter(() => this.opts, () => this.i18n);\n    _classPrivateFieldLooseBase(this, _storeUnsubscribe)[_storeUnsubscribe] = this.store.subscribe(\n    // eslint-disable-next-line\n    // @ts-ignore Store is incorrectly typed\n    (prevState, nextState, patch) => {\n      // eslint-disable-next-line\n      // @ts-ignore Store is incorrectly typed\n      this.emit('state-update', prevState, nextState, patch);\n      this.updateAll(nextState);\n    });\n\n    // Exposing uppy object on window for debugging and testing\n    if (this.opts.debug && typeof window !== 'undefined') {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore Mutating the global object for debug purposes\n      window[this.opts.id] = this;\n    }\n    _classPrivateFieldLooseBase(this, _addListeners)[_addListeners]();\n  }\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    _classPrivateFieldLooseBase(this, _emitter)[_emitter].emit(event, ...args);\n  }\n  on(event, callback) {\n    _classPrivateFieldLooseBase(this, _emitter)[_emitter].on(event, callback);\n    return this;\n  }\n  once(event, callback) {\n    _classPrivateFieldLooseBase(this, _emitter)[_emitter].once(event, callback);\n    return this;\n  }\n  off(event, callback) {\n    _classPrivateFieldLooseBase(this, _emitter)[_emitter].off(event, callback);\n    return this;\n  }\n\n  /**\n   * Iterate on all plugins and run `update` on them.\n   * Called each time state changes.\n   *\n   */\n  updateAll(state) {\n    this.iteratePlugins(plugin => {\n      plugin.update(state);\n    });\n  }\n\n  /**\n   * Updates state with a patch\n   */\n  setState(patch) {\n    // eslint-disable-next-line\n    // @ts-ignore Store is incorrectly typed\n    this.store.setState(patch);\n  }\n\n  /**\n   * Returns current state.\n   */\n  getState() {\n    // eslint-disable-next-line\n    // @ts-ignore Store is incorrectly typed\n    return this.store.getState();\n  }\n  patchFilesState(filesWithNewState) {\n    const existingFilesState = this.getState().files;\n    this.setState({\n      files: {\n        ...existingFilesState,\n        ...Object.fromEntries(Object.entries(filesWithNewState).map(_ref => {\n          let [fileID, newFileState] = _ref;\n          return [fileID, {\n            ...existingFilesState[fileID],\n            ...newFileState\n          }];\n        }))\n      }\n    });\n  }\n\n  /**\n   * Shorthand to set state for a specific file.\n   */\n  setFileState(fileID, state) {\n    if (!this.getState().files[fileID]) {\n      throw new Error(`Can’t set state for ${fileID} (the file could have been removed)`);\n    }\n    this.patchFilesState({\n      [fileID]: state\n    });\n  }\n  i18nInit() {\n    const onMissingKey = key => this.log(`Missing i18n string: ${key}`, 'error');\n    const translator = new Translator([this.defaultLocale, this.opts.locale], {\n      onMissingKey\n    });\n    this.i18n = translator.translate.bind(translator);\n    this.i18nArray = translator.translateArray.bind(translator);\n    this.locale = translator.locale;\n  }\n  setOptions(newOpts) {\n    this.opts = {\n      ...this.opts,\n      ...newOpts,\n      restrictions: {\n        ...this.opts.restrictions,\n        ...(newOpts == null ? void 0 : newOpts.restrictions)\n      }\n    };\n    if (newOpts.meta) {\n      this.setMeta(newOpts.meta);\n    }\n    this.i18nInit();\n    if (newOpts.locale) {\n      this.iteratePlugins(plugin => {\n        plugin.setOptions(newOpts);\n      });\n    }\n\n    // Note: this is not the preact `setState`, it's an internal function that has the same name.\n    this.setState(undefined); // so that UI re-renders with new options\n  }\n\n  // todo next major: remove\n  resetProgress() {\n    const defaultProgress = {\n      percentage: 0,\n      bytesUploaded: 0,\n      uploadComplete: false,\n      uploadStarted: null\n    };\n    const files = {\n      ...this.getState().files\n    };\n    const updatedFiles = {};\n    Object.keys(files).forEach(fileID => {\n      updatedFiles[fileID] = {\n        ...files[fileID],\n        progress: {\n          ...files[fileID].progress,\n          ...defaultProgress\n        }\n      };\n    });\n    this.setState({\n      files: updatedFiles,\n      ...defaultUploadState\n    });\n    this.emit('reset-progress');\n  }\n\n  // @todo next major: rename to `clear()`, make it also cancel ongoing uploads\n  // or throw and say you need to cancel manually\n  clearUploadedFiles() {\n    const {\n      capabilities,\n      currentUploads\n    } = this.getState();\n    if (Object.keys(currentUploads).length > 0 && !capabilities.individualCancellation) {\n      throw new Error('The installed uploader plugin does not allow removing files during an upload.');\n    }\n    this.setState({\n      ...defaultUploadState,\n      files: {}\n    });\n  }\n  addPreProcessor(fn) {\n    _classPrivateFieldLooseBase(this, _preProcessors)[_preProcessors].add(fn);\n  }\n  removePreProcessor(fn) {\n    return _classPrivateFieldLooseBase(this, _preProcessors)[_preProcessors].delete(fn);\n  }\n  addPostProcessor(fn) {\n    _classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors].add(fn);\n  }\n  removePostProcessor(fn) {\n    return _classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors].delete(fn);\n  }\n  addUploader(fn) {\n    _classPrivateFieldLooseBase(this, _uploaders)[_uploaders].add(fn);\n  }\n  removeUploader(fn) {\n    return _classPrivateFieldLooseBase(this, _uploaders)[_uploaders].delete(fn);\n  }\n  setMeta(data) {\n    const updatedMeta = {\n      ...this.getState().meta,\n      ...data\n    };\n    const updatedFiles = {\n      ...this.getState().files\n    };\n    Object.keys(updatedFiles).forEach(fileID => {\n      updatedFiles[fileID] = {\n        ...updatedFiles[fileID],\n        meta: {\n          ...updatedFiles[fileID].meta,\n          ...data\n        }\n      };\n    });\n    this.log('Adding metadata:');\n    this.log(data);\n    this.setState({\n      meta: updatedMeta,\n      files: updatedFiles\n    });\n  }\n  setFileMeta(fileID, data) {\n    const updatedFiles = {\n      ...this.getState().files\n    };\n    if (!updatedFiles[fileID]) {\n      this.log('Was trying to set metadata for a file that has been removed: ', fileID);\n      return;\n    }\n    const newMeta = {\n      ...updatedFiles[fileID].meta,\n      ...data\n    };\n    updatedFiles[fileID] = {\n      ...updatedFiles[fileID],\n      meta: newMeta\n    };\n    this.setState({\n      files: updatedFiles\n    });\n  }\n\n  /**\n   * Get a file object.\n   */\n  getFile(fileID) {\n    return this.getState().files[fileID];\n  }\n\n  /**\n   * Get all files in an array.\n   */\n  getFiles() {\n    const {\n      files\n    } = this.getState();\n    return Object.values(files);\n  }\n  getFilesByIds(ids) {\n    return ids.map(id => this.getFile(id));\n  }\n  getObjectOfFilesPerState() {\n    const {\n      files: filesObject,\n      totalProgress,\n      error\n    } = this.getState();\n    const files = Object.values(filesObject);\n    const inProgressFiles = [];\n    const newFiles = [];\n    const startedFiles = [];\n    const uploadStartedFiles = [];\n    const pausedFiles = [];\n    const completeFiles = [];\n    const erroredFiles = [];\n    const inProgressNotPausedFiles = [];\n    const processingFiles = [];\n    for (const file of files) {\n      const {\n        progress\n      } = file;\n      if (!progress.uploadComplete && progress.uploadStarted) {\n        inProgressFiles.push(file);\n        if (!file.isPaused) {\n          inProgressNotPausedFiles.push(file);\n        }\n      }\n      if (!progress.uploadStarted) {\n        newFiles.push(file);\n      }\n      if (progress.uploadStarted || progress.preprocess || progress.postprocess) {\n        startedFiles.push(file);\n      }\n      if (progress.uploadStarted) {\n        uploadStartedFiles.push(file);\n      }\n      if (file.isPaused) {\n        pausedFiles.push(file);\n      }\n      if (progress.uploadComplete) {\n        completeFiles.push(file);\n      }\n      if (file.error) {\n        erroredFiles.push(file);\n      }\n      if (progress.preprocess || progress.postprocess) {\n        processingFiles.push(file);\n      }\n    }\n    return {\n      newFiles,\n      startedFiles,\n      uploadStartedFiles,\n      pausedFiles,\n      completeFiles,\n      erroredFiles,\n      inProgressFiles,\n      inProgressNotPausedFiles,\n      processingFiles,\n      isUploadStarted: uploadStartedFiles.length > 0,\n      isAllComplete: totalProgress === 100 && completeFiles.length === files.length && processingFiles.length === 0,\n      isAllErrored: !!error && erroredFiles.length === files.length,\n      isAllPaused: inProgressFiles.length !== 0 && pausedFiles.length === inProgressFiles.length,\n      isUploadInProgress: inProgressFiles.length > 0,\n      isSomeGhost: files.some(file => file.isGhost)\n    };\n  }\n  validateRestrictions(file, files) {\n    if (files === void 0) {\n      files = this.getFiles();\n    }\n    try {\n      _classPrivateFieldLooseBase(this, _restricter)[_restricter].validate(files, [file]);\n    } catch (err) {\n      return err;\n    }\n    return null;\n  }\n  checkIfFileAlreadyExists(fileID) {\n    const {\n      files\n    } = this.getState();\n    if (files[fileID] && !files[fileID].isGhost) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Add a new file to `state.files`. This will run `onBeforeFileAdded`,\n   * try to guess file type in a clever way, check file against restrictions,\n   * and start an upload if `autoProceed === true`.\n   */\n  addFile(file) {\n    _classPrivateFieldLooseBase(this, _assertNewUploadAllowed)[_assertNewUploadAllowed](file);\n    const {\n      nextFilesState,\n      validFilesToAdd,\n      errors\n    } = _classPrivateFieldLooseBase(this, _checkAndUpdateFileState)[_checkAndUpdateFileState]([file]);\n    const restrictionErrors = errors.filter(error => error.isRestriction);\n    _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit](restrictionErrors);\n    if (errors.length > 0) throw errors[0];\n    this.setState({\n      files: nextFilesState\n    });\n    const [firstValidFileToAdd] = validFilesToAdd;\n    this.emit('file-added', firstValidFileToAdd);\n    this.emit('files-added', validFilesToAdd);\n    this.log(`Added file: ${firstValidFileToAdd.name}, ${firstValidFileToAdd.id}, mime type: ${firstValidFileToAdd.type}`);\n    _classPrivateFieldLooseBase(this, _startIfAutoProceed)[_startIfAutoProceed]();\n    return firstValidFileToAdd.id;\n  }\n\n  /**\n   * Add multiple files to `state.files`. See the `addFile()` documentation.\n   *\n   * If an error occurs while adding a file, it is logged and the user is notified.\n   * This is good for UI plugins, but not for programmatic use.\n   * Programmatic users should usually still use `addFile()` on individual files.\n   */\n  addFiles(fileDescriptors) {\n    _classPrivateFieldLooseBase(this, _assertNewUploadAllowed)[_assertNewUploadAllowed]();\n    const {\n      nextFilesState,\n      validFilesToAdd,\n      errors\n    } = _classPrivateFieldLooseBase(this, _checkAndUpdateFileState)[_checkAndUpdateFileState](fileDescriptors);\n    const restrictionErrors = errors.filter(error => error.isRestriction);\n    _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit](restrictionErrors);\n    const nonRestrictionErrors = errors.filter(error => !error.isRestriction);\n    if (nonRestrictionErrors.length > 0) {\n      let message = 'Multiple errors occurred while adding files:\\n';\n      nonRestrictionErrors.forEach(subError => {\n        message += `\\n * ${subError.message}`;\n      });\n      this.info({\n        message: this.i18n('addBulkFilesFailed', {\n          smart_count: nonRestrictionErrors.length\n        }),\n        details: message\n      }, 'error', this.opts.infoTimeout);\n      if (typeof AggregateError === 'function') {\n        throw new AggregateError(nonRestrictionErrors, message);\n      } else {\n        const err = new Error(message);\n        // @ts-expect-error fallback when AggregateError is not available\n        err.errors = nonRestrictionErrors;\n        throw err;\n      }\n    }\n\n    // OK, we haven't thrown an error, we can start updating state and emitting events now:\n\n    this.setState({\n      files: nextFilesState\n    });\n    validFilesToAdd.forEach(file => {\n      this.emit('file-added', file);\n    });\n    this.emit('files-added', validFilesToAdd);\n    if (validFilesToAdd.length > 5) {\n      this.log(`Added batch of ${validFilesToAdd.length} files`);\n    } else {\n      Object.values(validFilesToAdd).forEach(file => {\n        this.log(`Added file: ${file.name}\\n id: ${file.id}\\n type: ${file.type}`);\n      });\n    }\n    if (validFilesToAdd.length > 0) {\n      _classPrivateFieldLooseBase(this, _startIfAutoProceed)[_startIfAutoProceed]();\n    }\n  }\n  removeFiles(fileIDs, reason) {\n    const {\n      files,\n      currentUploads\n    } = this.getState();\n    const updatedFiles = {\n      ...files\n    };\n    const updatedUploads = {\n      ...currentUploads\n    };\n    const removedFiles = Object.create(null);\n    fileIDs.forEach(fileID => {\n      if (files[fileID]) {\n        removedFiles[fileID] = files[fileID];\n        delete updatedFiles[fileID];\n      }\n    });\n\n    // Remove files from the `fileIDs` list in each upload.\n    function fileIsNotRemoved(uploadFileID) {\n      return removedFiles[uploadFileID] === undefined;\n    }\n    Object.keys(updatedUploads).forEach(uploadID => {\n      const newFileIDs = currentUploads[uploadID].fileIDs.filter(fileIsNotRemoved);\n\n      // Remove the upload if no files are associated with it anymore.\n      if (newFileIDs.length === 0) {\n        delete updatedUploads[uploadID];\n        return;\n      }\n      const {\n        capabilities\n      } = this.getState();\n      if (newFileIDs.length !== currentUploads[uploadID].fileIDs.length && !capabilities.individualCancellation) {\n        throw new Error('The installed uploader plugin does not allow removing files during an upload.');\n      }\n      updatedUploads[uploadID] = {\n        ...currentUploads[uploadID],\n        fileIDs: newFileIDs\n      };\n    });\n    const stateUpdate = {\n      currentUploads: updatedUploads,\n      files: updatedFiles\n    };\n\n    // If all files were removed - allow new uploads,\n    // and clear recoveredState\n    if (Object.keys(updatedFiles).length === 0) {\n      stateUpdate.allowNewUpload = true;\n      stateUpdate.error = null;\n      stateUpdate.recoveredState = null;\n    }\n    this.setState(stateUpdate);\n    this.calculateTotalProgress();\n    const removedFileIDs = Object.keys(removedFiles);\n    removedFileIDs.forEach(fileID => {\n      this.emit('file-removed', removedFiles[fileID], reason);\n    });\n    if (removedFileIDs.length > 5) {\n      this.log(`Removed ${removedFileIDs.length} files`);\n    } else {\n      this.log(`Removed files: ${removedFileIDs.join(', ')}`);\n    }\n  }\n  removeFile(fileID, reason) {\n    this.removeFiles([fileID], reason);\n  }\n  pauseResume(fileID) {\n    if (!this.getState().capabilities.resumableUploads || this.getFile(fileID).progress.uploadComplete) {\n      return undefined;\n    }\n    const wasPaused = this.getFile(fileID).isPaused || false;\n    const isPaused = !wasPaused;\n    this.setFileState(fileID, {\n      isPaused\n    });\n    this.emit('upload-pause', fileID, isPaused);\n    return isPaused;\n  }\n  pauseAll() {\n    const updatedFiles = {\n      ...this.getState().files\n    };\n    const inProgressUpdatedFiles = Object.keys(updatedFiles).filter(file => {\n      return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;\n    });\n    inProgressUpdatedFiles.forEach(file => {\n      const updatedFile = {\n        ...updatedFiles[file],\n        isPaused: true\n      };\n      updatedFiles[file] = updatedFile;\n    });\n    this.setState({\n      files: updatedFiles\n    });\n    this.emit('pause-all');\n  }\n  resumeAll() {\n    const updatedFiles = {\n      ...this.getState().files\n    };\n    const inProgressUpdatedFiles = Object.keys(updatedFiles).filter(file => {\n      return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;\n    });\n    inProgressUpdatedFiles.forEach(file => {\n      const updatedFile = {\n        ...updatedFiles[file],\n        isPaused: false,\n        error: null\n      };\n      updatedFiles[file] = updatedFile;\n    });\n    this.setState({\n      files: updatedFiles\n    });\n    this.emit('resume-all');\n  }\n  retryAll() {\n    const updatedFiles = {\n      ...this.getState().files\n    };\n    const filesToRetry = Object.keys(updatedFiles).filter(file => {\n      return updatedFiles[file].error;\n    });\n    filesToRetry.forEach(file => {\n      const updatedFile = {\n        ...updatedFiles[file],\n        isPaused: false,\n        error: null\n      };\n      updatedFiles[file] = updatedFile;\n    });\n    this.setState({\n      files: updatedFiles,\n      error: null\n    });\n    this.emit('retry-all', filesToRetry);\n    if (filesToRetry.length === 0) {\n      return Promise.resolve({\n        successful: [],\n        failed: []\n      });\n    }\n    const uploadID = _classPrivateFieldLooseBase(this, _createUpload)[_createUpload](filesToRetry, {\n      forceAllowNewUpload: true // create new upload even if allowNewUpload: false\n    });\n    return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);\n  }\n  cancelAll(_temp) {\n    let {\n      reason = 'user'\n    } = _temp === void 0 ? {} : _temp;\n    this.emit('cancel-all', {\n      reason\n    });\n\n    // Only remove existing uploads if user is canceling\n    if (reason === 'user') {\n      const {\n        files\n      } = this.getState();\n      const fileIDs = Object.keys(files);\n      if (fileIDs.length) {\n        this.removeFiles(fileIDs, 'cancel-all');\n      }\n      this.setState(defaultUploadState);\n      // todo should we call this.emit('reset-progress') like we do for resetProgress?\n    }\n  }\n  retryUpload(fileID) {\n    this.setFileState(fileID, {\n      error: null,\n      isPaused: false\n    });\n    this.emit('upload-retry', fileID);\n    const uploadID = _classPrivateFieldLooseBase(this, _createUpload)[_createUpload]([fileID], {\n      forceAllowNewUpload: true // create new upload even if allowNewUpload: false\n    });\n    return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);\n  }\n  logout() {\n    this.iteratePlugins(plugin => {\n      var _provider;\n      ;\n      (_provider = plugin.provider) == null || _provider.logout == null || _provider.logout();\n    });\n  }\n  calculateTotalProgress() {\n    // calculate total progress, using the number of files currently uploading,\n    // multiplied by 100 and the summ of individual progress of each file\n    const files = this.getFiles();\n    const inProgress = files.filter(file => {\n      return file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess;\n    });\n    if (inProgress.length === 0) {\n      this.emit('progress', 0);\n      this.setState({\n        totalProgress: 0\n      });\n      return;\n    }\n    const sizedFiles = inProgress.filter(file => file.progress.bytesTotal != null);\n    const unsizedFiles = inProgress.filter(file => file.progress.bytesTotal == null);\n    if (sizedFiles.length === 0) {\n      const progressMax = inProgress.length * 100;\n      const currentProgress = unsizedFiles.reduce((acc, file) => {\n        return acc + file.progress.percentage;\n      }, 0);\n      const totalProgress = Math.round(currentProgress / progressMax * 100);\n      this.setState({\n        totalProgress\n      });\n      return;\n    }\n    let totalSize = sizedFiles.reduce((acc, file) => {\n      var _file$progress$bytesT;\n      return acc + ((_file$progress$bytesT = file.progress.bytesTotal) != null ? _file$progress$bytesT : 0);\n    }, 0);\n    const averageSize = totalSize / sizedFiles.length;\n    totalSize += averageSize * unsizedFiles.length;\n    let uploadedSize = 0;\n    sizedFiles.forEach(file => {\n      uploadedSize += file.progress.bytesUploaded;\n    });\n    unsizedFiles.forEach(file => {\n      uploadedSize += averageSize * (file.progress.percentage || 0) / 100;\n    });\n    let totalProgress = totalSize === 0 ? 0 : Math.round(uploadedSize / totalSize * 100);\n\n    // hot fix, because:\n    // uploadedSize ended up larger than totalSize, resulting in 1325% total\n    if (totalProgress > 100) {\n      totalProgress = 100;\n    }\n    this.setState({\n      totalProgress\n    });\n    this.emit('progress', totalProgress);\n  }\n  updateOnlineStatus() {\n    var _window$navigator$onL;\n    const online = (_window$navigator$onL = window.navigator.onLine) != null ? _window$navigator$onL : true;\n    if (!online) {\n      this.emit('is-offline');\n      this.info(this.i18n('noInternetConnection'), 'error', 0);\n      this.wasOffline = true;\n    } else {\n      this.emit('is-online');\n      if (this.wasOffline) {\n        this.emit('back-online');\n        this.info(this.i18n('connectedToInternet'), 'success', 3000);\n        this.wasOffline = false;\n      }\n    }\n  }\n  getID() {\n    return this.opts.id;\n  }\n\n  /**\n   * Registers a plugin with Core.\n   */\n  use(Plugin, opts) {\n    if (typeof Plugin !== 'function') {\n      const msg = `Expected a plugin class, but got ${Plugin === null ? 'null' : typeof Plugin}.` + ' Please verify that the plugin was imported and spelled correctly.';\n      throw new TypeError(msg);\n    }\n\n    // Instantiate\n    const plugin = new Plugin(this, opts);\n    const pluginId = plugin.id;\n    if (!pluginId) {\n      throw new Error('Your plugin must have an id');\n    }\n    if (!plugin.type) {\n      throw new Error('Your plugin must have a type');\n    }\n    const existsPluginAlready = this.getPlugin(pluginId);\n    if (existsPluginAlready) {\n      const msg = `Already found a plugin named '${existsPluginAlready.id}'. ` + `Tried to use: '${pluginId}'.\\n` + 'Uppy plugins must have unique `id` options. See https://uppy.io/docs/plugins/#id.';\n      throw new Error(msg);\n    }\n\n    // @ts-expect-error does exist\n    if (Plugin.VERSION) {\n      // @ts-expect-error does exist\n      this.log(`Using ${pluginId} v${Plugin.VERSION}`);\n    }\n    if (plugin.type in _classPrivateFieldLooseBase(this, _plugins)[_plugins]) {\n      _classPrivateFieldLooseBase(this, _plugins)[_plugins][plugin.type].push(plugin);\n    } else {\n      _classPrivateFieldLooseBase(this, _plugins)[_plugins][plugin.type] = [plugin];\n    }\n    plugin.install();\n    this.emit('plugin-added', plugin);\n    return this;\n  }\n\n  /**\n   * Find one Plugin by name.\n   */\n  getPlugin(id) {\n    for (const plugins of Object.values(_classPrivateFieldLooseBase(this, _plugins)[_plugins])) {\n      const foundPlugin = plugins.find(plugin => plugin.id === id);\n      if (foundPlugin != null) return foundPlugin;\n    }\n    return undefined;\n  }\n  [_Symbol$for](type) {\n    return _classPrivateFieldLooseBase(this, _plugins)[_plugins][type];\n  }\n\n  /**\n   * Iterate through all `use`d plugins.\n   *\n   */\n  iteratePlugins(method) {\n    Object.values(_classPrivateFieldLooseBase(this, _plugins)[_plugins]).flat(1).forEach(method);\n  }\n\n  /**\n   * Uninstall and remove a plugin.\n   *\n   * @param {object} instance The plugin instance to remove.\n   */\n  removePlugin(instance) {\n    this.log(`Removing plugin ${instance.id}`);\n    this.emit('plugin-remove', instance);\n    if (instance.uninstall) {\n      instance.uninstall();\n    }\n    const list = _classPrivateFieldLooseBase(this, _plugins)[_plugins][instance.type];\n    // list.indexOf failed here, because Vue3 converted the plugin instance\n    // to a Proxy object, which failed the strict comparison test:\n    // obj !== objProxy\n    const index = list.findIndex(item => item.id === instance.id);\n    if (index !== -1) {\n      list.splice(index, 1);\n    }\n    const state = this.getState();\n    const updatedState = {\n      plugins: {\n        ...state.plugins,\n        [instance.id]: undefined\n      }\n    };\n    this.setState(updatedState);\n  }\n\n  /**\n   * Uninstall all plugins and close down this Uppy instance.\n   */\n  // @todo next major: rename to `destroy`.\n  // Cancel local uploads, cancel remote uploads, DON'T cancel assemblies\n  // document that if you do want to cancel assemblies, you need to call smth manually.\n  // Potentially remove reason, as it’s confusing, just come up with a default behaviour.\n  close(_temp2) {\n    let {\n      reason\n    } = _temp2 === void 0 ? {} : _temp2;\n    this.log(`Closing Uppy instance ${this.opts.id}: removing all files and uninstalling plugins`);\n    this.cancelAll({\n      reason\n    });\n    _classPrivateFieldLooseBase(this, _storeUnsubscribe)[_storeUnsubscribe]();\n    this.iteratePlugins(plugin => {\n      this.removePlugin(plugin);\n    });\n    if (typeof window !== 'undefined' && window.removeEventListener) {\n      window.removeEventListener('online', _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);\n      window.removeEventListener('offline', _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);\n    }\n  }\n  hideInfo() {\n    const {\n      info\n    } = this.getState();\n    this.setState({\n      info: info.slice(1)\n    });\n    this.emit('info-hidden');\n  }\n\n  /**\n   * Set info message in `state.info`, so that UI plugins like `Informer`\n   * can display the message.\n   */\n  info(message, type, duration) {\n    if (type === void 0) {\n      type = 'info';\n    }\n    if (duration === void 0) {\n      duration = 3000;\n    }\n    const isComplexMessage = typeof message === 'object';\n    this.setState({\n      info: [...this.getState().info, {\n        type,\n        message: isComplexMessage ? message.message : message,\n        details: isComplexMessage ? message.details : null\n      }]\n    });\n    setTimeout(() => this.hideInfo(), duration);\n    this.emit('info-visible');\n  }\n\n  /**\n   * Passes messages to a function, provided in `opts.logger`.\n   * If `opts.logger: Uppy.debugLogger` or `opts.debug: true`, logs to the browser console.\n   */\n  log(message, type) {\n    const {\n      logger\n    } = this.opts;\n    switch (type) {\n      case 'error':\n        logger.error(message);\n        break;\n      case 'warning':\n        logger.warn(message);\n        break;\n      default:\n        logger.debug(message);\n        break;\n    }\n  }\n  registerRequestClient(id, client) {\n    _classPrivateFieldLooseBase(this, _requestClientById)[_requestClientById].set(id, client);\n  }\n\n  /** @protected */\n  getRequestClientForFile(file) {\n    if (!file.remote) throw new Error(`Tried to get RequestClient for a non-remote file ${file.id}`);\n    const requestClient = _classPrivateFieldLooseBase(this, _requestClientById)[_requestClientById].get(file.remote.requestClientId);\n    if (requestClient == null) throw new Error(`requestClientId \"${file.remote.requestClientId}\" not registered for file \"${file.id}\"`);\n    return requestClient;\n  }\n\n  /**\n   * Restore an upload by its ID.\n   */\n  restore(uploadID) {\n    this.log(`Core: attempting to restore upload \"${uploadID}\"`);\n    if (!this.getState().currentUploads[uploadID]) {\n      _classPrivateFieldLooseBase(this, _removeUpload)[_removeUpload](uploadID);\n      return Promise.reject(new Error('Nonexistent upload'));\n    }\n    return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);\n  }\n  [_Symbol$for2]() {\n    // @ts-expect-error https://github.com/microsoft/TypeScript/issues/47595\n    return _classPrivateFieldLooseBase(this, _createUpload)[_createUpload](...arguments);\n  }\n  /**\n   * Add data to an upload's result object.\n   */\n  addResultData(uploadID, data) {\n    if (!_classPrivateFieldLooseBase(this, _getUpload)[_getUpload](uploadID)) {\n      this.log(`Not setting result for an upload that has been removed: ${uploadID}`);\n      return;\n    }\n    const {\n      currentUploads\n    } = this.getState();\n    const currentUpload = {\n      ...currentUploads[uploadID],\n      result: {\n        ...currentUploads[uploadID].result,\n        ...data\n      }\n    };\n    this.setState({\n      currentUploads: {\n        ...currentUploads,\n        [uploadID]: currentUpload\n      }\n    });\n  }\n  /**\n   * Start an upload for all the files that are not currently being uploaded.\n   */\n  upload() {\n    var _classPrivateFieldLoo;\n    if (!((_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _plugins)[_plugins]['uploader']) != null && _classPrivateFieldLoo.length)) {\n      this.log('No uploader type plugins are used', 'warning');\n    }\n    let {\n      files\n    } = this.getState();\n    const onBeforeUploadResult = this.opts.onBeforeUpload(files);\n    if (onBeforeUploadResult === false) {\n      return Promise.reject(new Error('Not starting the upload because onBeforeUpload returned false'));\n    }\n    if (onBeforeUploadResult && typeof onBeforeUploadResult === 'object') {\n      files = onBeforeUploadResult;\n      // Updating files in state, because uploader plugins receive file IDs,\n      // and then fetch the actual file object from state\n      this.setState({\n        files\n      });\n    }\n    return Promise.resolve().then(() => _classPrivateFieldLooseBase(this, _restricter)[_restricter].validateMinNumberOfFiles(files)).catch(err => {\n      _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit]([err]);\n      throw err;\n    }).then(() => {\n      if (!_classPrivateFieldLooseBase(this, _checkRequiredMetaFields)[_checkRequiredMetaFields](files)) {\n        throw new RestrictionError(this.i18n('missingRequiredMetaField'));\n      }\n    }).catch(err => {\n      // Doing this in a separate catch because we already emited and logged\n      // all the errors in `checkRequiredMetaFields` so we only throw a generic\n      // missing fields error here.\n      throw err;\n    }).then(() => {\n      const {\n        currentUploads\n      } = this.getState();\n      // get a list of files that are currently assigned to uploads\n      const currentlyUploadingFiles = Object.values(currentUploads).flatMap(curr => curr.fileIDs);\n      const waitingFileIDs = [];\n      Object.keys(files).forEach(fileID => {\n        const file = this.getFile(fileID);\n        // if the file hasn't started uploading and hasn't already been assigned to an upload..\n        if (!file.progress.uploadStarted && currentlyUploadingFiles.indexOf(fileID) === -1) {\n          waitingFileIDs.push(file.id);\n        }\n      });\n      const uploadID = _classPrivateFieldLooseBase(this, _createUpload)[_createUpload](waitingFileIDs);\n      return _classPrivateFieldLooseBase(this, _runUpload)[_runUpload](uploadID);\n    }).catch(err => {\n      this.emit('error', err);\n      this.log(err, 'error');\n      throw err;\n    });\n  }\n}\nfunction _informAndEmit2(errors) {\n  for (const error of errors) {\n    if (error.isRestriction) {\n      this.emit('restriction-failed', error.file, error);\n    } else {\n      this.emit('error', error, error.file);\n    }\n    this.log(error, 'warning');\n  }\n  const userFacingErrors = errors.filter(error => error.isUserFacing);\n\n  // don't flood the user: only show the first 4 toasts\n  const maxNumToShow = 4;\n  const firstErrors = userFacingErrors.slice(0, maxNumToShow);\n  const additionalErrors = userFacingErrors.slice(maxNumToShow);\n  firstErrors.forEach(_ref2 => {\n    let {\n      message,\n      details = ''\n    } = _ref2;\n    this.info({\n      message,\n      details\n    }, 'error', this.opts.infoTimeout);\n  });\n  if (additionalErrors.length > 0) {\n    this.info({\n      message: this.i18n('additionalRestrictionsFailed', {\n        count: additionalErrors.length\n      })\n    });\n  }\n}\nfunction _checkRequiredMetaFieldsOnFile2(file) {\n  const {\n    missingFields,\n    error\n  } = _classPrivateFieldLooseBase(this, _restricter)[_restricter].getMissingRequiredMetaFields(file);\n  if (missingFields.length > 0) {\n    this.setFileState(file.id, {\n      missingRequiredMetaFields: missingFields\n    });\n    this.log(error.message);\n    this.emit('restriction-failed', file, error);\n    return false;\n  }\n  return true;\n}\nfunction _checkRequiredMetaFields2(files) {\n  let success = true;\n  for (const file of Object.values(files)) {\n    if (!_classPrivateFieldLooseBase(this, _checkRequiredMetaFieldsOnFile)[_checkRequiredMetaFieldsOnFile](file)) {\n      success = false;\n    }\n  }\n  return success;\n}\nfunction _assertNewUploadAllowed2(file) {\n  const {\n    allowNewUpload\n  } = this.getState();\n  if (allowNewUpload === false) {\n    const error = new RestrictionError(this.i18n('noMoreFilesAllowed'), {\n      file\n    });\n    _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit]([error]);\n    throw error;\n  }\n}\nfunction _transformFile2(fileDescriptorOrFile) {\n  // Uppy expects files in { name, type, size, data } format.\n  // If the actual File object is passed from input[type=file] or drag-drop,\n  // we normalize it to match Uppy file object\n  const file = fileDescriptorOrFile instanceof File ? {\n    name: fileDescriptorOrFile.name,\n    type: fileDescriptorOrFile.type,\n    size: fileDescriptorOrFile.size,\n    data: fileDescriptorOrFile\n  } : fileDescriptorOrFile;\n  const fileType = getFileType(file);\n  const fileName = getFileName(fileType, file);\n  const fileExtension = getFileNameAndExtension(fileName).extension;\n  const id = getSafeFileId(file, this.getID());\n  const meta = file.meta || {};\n  meta.name = fileName;\n  meta.type = fileType;\n\n  // `null` means the size is unknown.\n  const size = Number.isFinite(file.data.size) ? file.data.size : null;\n  return {\n    source: file.source || '',\n    id,\n    name: fileName,\n    extension: fileExtension || '',\n    meta: {\n      ...this.getState().meta,\n      ...meta\n    },\n    type: fileType,\n    data: file.data,\n    progress: {\n      percentage: 0,\n      bytesUploaded: 0,\n      bytesTotal: size,\n      uploadComplete: false,\n      uploadStarted: null\n    },\n    size,\n    isGhost: false,\n    isRemote: file.isRemote || false,\n    // TODO: this should not be a string\n    // @ts-expect-error wrong\n    remote: file.remote || '',\n    preview: file.preview\n  };\n}\nfunction _startIfAutoProceed2() {\n  if (this.opts.autoProceed && !this.scheduledAutoProceed) {\n    this.scheduledAutoProceed = setTimeout(() => {\n      this.scheduledAutoProceed = null;\n      this.upload().catch(err => {\n        if (!err.isRestriction) {\n          this.log(err.stack || err.message || err);\n        }\n      });\n    }, 4);\n  }\n}\nfunction _checkAndUpdateFileState2(filesToAdd) {\n  const {\n    files: existingFiles\n  } = this.getState();\n\n  // create a copy of the files object only once\n  const nextFilesState = {\n    ...existingFiles\n  };\n  const validFilesToAdd = [];\n  const errors = [];\n  for (const fileToAdd of filesToAdd) {\n    try {\n      var _existingFiles$newFil;\n      let newFile = _classPrivateFieldLooseBase(this, _transformFile)[_transformFile](fileToAdd);\n\n      // If a file has been recovered (Golden Retriever), but we were unable to recover its data (probably too large),\n      // users are asked to re-select these half-recovered files and then this method will be called again.\n      // In order to keep the progress, meta and everything else, we keep the existing file,\n      // but we replace `data`, and we remove `isGhost`, because the file is no longer a ghost now\n      const isGhost = (_existingFiles$newFil = existingFiles[newFile.id]) == null ? void 0 : _existingFiles$newFil.isGhost;\n      if (isGhost) {\n        const existingFileState = existingFiles[newFile.id];\n        newFile = {\n          ...existingFileState,\n          isGhost: false,\n          data: fileToAdd.data\n        };\n        this.log(`Replaced the blob in the restored ghost file: ${newFile.name}, ${newFile.id}`);\n      }\n      const onBeforeFileAddedResult = this.opts.onBeforeFileAdded(newFile, nextFilesState);\n      if (!onBeforeFileAddedResult && this.checkIfFileAlreadyExists(newFile.id)) {\n        throw new RestrictionError(this.i18n('noDuplicates', {\n          fileName: newFile.name\n        }), {\n          file: fileToAdd\n        });\n      }\n\n      // Pass through reselected files from Golden Retriever\n      if (onBeforeFileAddedResult === false && !isGhost) {\n        // Don’t show UI info for this error, as it should be done by the developer\n        throw new RestrictionError('Cannot add the file because onBeforeFileAdded returned false.', {\n          isUserFacing: false,\n          file: fileToAdd\n        });\n      } else if (typeof onBeforeFileAddedResult === 'object' && onBeforeFileAddedResult !== null) {\n        newFile = onBeforeFileAddedResult;\n      }\n      _classPrivateFieldLooseBase(this, _restricter)[_restricter].validateSingleFile(newFile);\n\n      // need to add it to the new local state immediately, so we can use the state to validate the next files too\n      nextFilesState[newFile.id] = newFile;\n      validFilesToAdd.push(newFile);\n    } catch (err) {\n      errors.push(err);\n    }\n  }\n  try {\n    // need to run this separately because it's much more slow, so if we run it inside the for-loop it will be very slow\n    // when many files are added\n    _classPrivateFieldLooseBase(this, _restricter)[_restricter].validateAggregateRestrictions(Object.values(existingFiles), validFilesToAdd);\n  } catch (err) {\n    errors.push(err);\n\n    // If we have any aggregate error, don't allow adding this batch\n    return {\n      nextFilesState: existingFiles,\n      validFilesToAdd: [],\n      errors\n    };\n  }\n  return {\n    nextFilesState,\n    validFilesToAdd,\n    errors\n  };\n}\nfunction _addListeners2() {\n  // Type inference only works for inline functions so we have to type it again\n  const errorHandler = (error, file, response) => {\n    let errorMsg = error.message || 'Unknown error';\n    if (error.details) {\n      errorMsg += ` ${error.details}`;\n    }\n    this.setState({\n      error: errorMsg\n    });\n    if (file != null && file.id in this.getState().files) {\n      this.setFileState(file.id, {\n        error: errorMsg,\n        response\n      });\n    }\n  };\n  this.on('error', errorHandler);\n  this.on('upload-error', (file, error, response) => {\n    errorHandler(error, file, response);\n    if (typeof error === 'object' && error.message) {\n      var _file$name;\n      this.log(error.message, 'error');\n      const newError = new Error(this.i18n('failedToUpload', {\n        file: (_file$name = file == null ? void 0 : file.name) != null ? _file$name : ''\n      })); // we may want a new custom error here\n      newError.isUserFacing = true; // todo maybe don't do this with all errors?\n      newError.details = error.message;\n      if (error.details) {\n        newError.details += ` ${error.details}`;\n      }\n      _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit]([newError]);\n    } else {\n      _classPrivateFieldLooseBase(this, _informAndEmit)[_informAndEmit]([error]);\n    }\n  });\n  let uploadStalledWarningRecentlyEmitted = null;\n  this.on('upload-stalled', (error, files) => {\n    const {\n      message\n    } = error;\n    const details = files.map(file => file.meta.name).join(', ');\n    if (!uploadStalledWarningRecentlyEmitted) {\n      this.info({\n        message,\n        details\n      }, 'warning', this.opts.infoTimeout);\n      uploadStalledWarningRecentlyEmitted = setTimeout(() => {\n        uploadStalledWarningRecentlyEmitted = null;\n      }, this.opts.infoTimeout);\n    }\n    this.log(`${message} ${details}`.trim(), 'warning');\n  });\n  this.on('upload', () => {\n    this.setState({\n      error: null\n    });\n  });\n  const onUploadStarted = files => {\n    const filesFiltered = files.filter(file => {\n      const exists = file != null && this.getFile(file.id);\n      if (!exists) this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);\n      return exists;\n    });\n    const filesState = Object.fromEntries(filesFiltered.map(file => [file.id, {\n      progress: {\n        uploadStarted: Date.now(),\n        uploadComplete: false,\n        percentage: 0,\n        bytesUploaded: 0,\n        bytesTotal: file.size\n      }\n    }]));\n    this.patchFilesState(filesState);\n  };\n  this.on('upload-start', files => {\n    files.forEach(file => {\n      // todo backward compat, remove this event in a next major\n      this.emit('upload-started', file);\n    });\n    onUploadStarted(files);\n  });\n  this.on('upload-progress', this.calculateProgress);\n  this.on('upload-success', (file, uploadResp) => {\n    if (file == null || !this.getFile(file.id)) {\n      this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);\n      return;\n    }\n    const currentProgress = this.getFile(file.id).progress;\n    this.setFileState(file.id, {\n      progress: {\n        ...currentProgress,\n        postprocess: _classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors].size > 0 ? {\n          mode: 'indeterminate'\n        } : undefined,\n        uploadComplete: true,\n        percentage: 100,\n        bytesUploaded: currentProgress.bytesTotal\n      },\n      response: uploadResp,\n      uploadURL: uploadResp.uploadURL,\n      isPaused: false\n    });\n\n    // Remote providers sometimes don't tell us the file size,\n    // but we can know how many bytes we uploaded once the upload is complete.\n    if (file.size == null) {\n      this.setFileState(file.id, {\n        size: uploadResp.bytesUploaded || currentProgress.bytesTotal\n      });\n    }\n    this.calculateTotalProgress();\n  });\n  this.on('preprocess-progress', (file, progress) => {\n    if (file == null || !this.getFile(file.id)) {\n      this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);\n      return;\n    }\n    this.setFileState(file.id, {\n      progress: {\n        ...this.getFile(file.id).progress,\n        preprocess: progress\n      }\n    });\n  });\n  this.on('preprocess-complete', file => {\n    if (file == null || !this.getFile(file.id)) {\n      this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);\n      return;\n    }\n    const files = {\n      ...this.getState().files\n    };\n    files[file.id] = {\n      ...files[file.id],\n      progress: {\n        ...files[file.id].progress\n      }\n    };\n    delete files[file.id].progress.preprocess;\n    this.setState({\n      files\n    });\n  });\n  this.on('postprocess-progress', (file, progress) => {\n    if (file == null || !this.getFile(file.id)) {\n      this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);\n      return;\n    }\n    this.setFileState(file.id, {\n      progress: {\n        ...this.getState().files[file.id].progress,\n        postprocess: progress\n      }\n    });\n  });\n  this.on('postprocess-complete', file => {\n    if (file == null || !this.getFile(file.id)) {\n      this.log(`Not setting progress for a file that has been removed: ${file == null ? void 0 : file.id}`);\n      return;\n    }\n    const files = {\n      ...this.getState().files\n    };\n    files[file.id] = {\n      ...files[file.id],\n      progress: {\n        ...files[file.id].progress\n      }\n    };\n    delete files[file.id].progress.postprocess;\n    this.setState({\n      files\n    });\n  });\n  this.on('restored', () => {\n    // Files may have changed--ensure progress is still accurate.\n    this.calculateTotalProgress();\n  });\n\n  // @ts-expect-error should fix itself when dashboard it typed (also this doesn't belong here)\n  this.on('dashboard:file-edit-complete', file => {\n    if (file) {\n      _classPrivateFieldLooseBase(this, _checkRequiredMetaFieldsOnFile)[_checkRequiredMetaFieldsOnFile](file);\n    }\n  });\n\n  // show informer if offline\n  if (typeof window !== 'undefined' && window.addEventListener) {\n    window.addEventListener('online', _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);\n    window.addEventListener('offline', _classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus]);\n    setTimeout(_classPrivateFieldLooseBase(this, _updateOnlineStatus)[_updateOnlineStatus], 3000);\n  }\n}\nfunction _createUpload2(fileIDs, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  // uppy.retryAll sets this to true — when retrying we want to ignore `allowNewUpload: false`\n  const {\n    forceAllowNewUpload = false\n  } = opts;\n  const {\n    allowNewUpload,\n    currentUploads\n  } = this.getState();\n  if (!allowNewUpload && !forceAllowNewUpload) {\n    throw new Error('Cannot create a new upload: already uploading.');\n  }\n  const uploadID = nanoid();\n  this.emit('upload', {\n    id: uploadID,\n    fileIDs\n  });\n  this.setState({\n    allowNewUpload: this.opts.allowMultipleUploadBatches !== false && this.opts.allowMultipleUploads !== false,\n    currentUploads: {\n      ...currentUploads,\n      [uploadID]: {\n        fileIDs,\n        step: 0,\n        result: {}\n      }\n    }\n  });\n  return uploadID;\n}\nfunction _getUpload2(uploadID) {\n  const {\n    currentUploads\n  } = this.getState();\n  return currentUploads[uploadID];\n}\nfunction _removeUpload2(uploadID) {\n  const currentUploads = {\n    ...this.getState().currentUploads\n  };\n  delete currentUploads[uploadID];\n  this.setState({\n    currentUploads\n  });\n}\nasync function _runUpload2(uploadID) {\n  const getCurrentUpload = () => {\n    const {\n      currentUploads\n    } = this.getState();\n    return currentUploads[uploadID];\n  };\n  let currentUpload = getCurrentUpload();\n  const steps = [..._classPrivateFieldLooseBase(this, _preProcessors)[_preProcessors], ..._classPrivateFieldLooseBase(this, _uploaders)[_uploaders], ..._classPrivateFieldLooseBase(this, _postProcessors)[_postProcessors]];\n  try {\n    for (let step = currentUpload.step || 0; step < steps.length; step++) {\n      if (!currentUpload) {\n        break;\n      }\n      const fn = steps[step];\n      this.setState({\n        currentUploads: {\n          ...this.getState().currentUploads,\n          [uploadID]: {\n            ...currentUpload,\n            step\n          }\n        }\n      });\n      const {\n        fileIDs\n      } = currentUpload;\n\n      // TODO give this the `updatedUpload` object as its only parameter maybe?\n      // Otherwise when more metadata may be added to the upload this would keep getting more parameters\n      await fn(fileIDs, uploadID);\n\n      // Update currentUpload value in case it was modified asynchronously.\n      currentUpload = getCurrentUpload();\n    }\n  } catch (err) {\n    _classPrivateFieldLooseBase(this, _removeUpload)[_removeUpload](uploadID);\n    throw err;\n  }\n\n  // Set result data.\n  if (currentUpload) {\n    // Mark postprocessing step as complete if necessary; this addresses a case where we might get\n    // stuck in the postprocessing UI while the upload is fully complete.\n    // If the postprocessing steps do not do any work, they may not emit postprocessing events at\n    // all, and never mark the postprocessing as complete. This is fine on its own but we\n    // introduced code in the @uppy/core upload-success handler to prepare postprocessing progress\n    // state if any postprocessors are registered. That is to avoid a \"flash of completed state\"\n    // before the postprocessing plugins can emit events.\n    //\n    // So, just in case an upload with postprocessing plugins *has* completed *without* emitting\n    // postprocessing completion, we do it instead.\n    currentUpload.fileIDs.forEach(fileID => {\n      const file = this.getFile(fileID);\n      if (file && file.progress.postprocess) {\n        this.emit('postprocess-complete', file);\n      }\n    });\n    const files = currentUpload.fileIDs.map(fileID => this.getFile(fileID));\n    const successful = files.filter(file => !file.error);\n    const failed = files.filter(file => file.error);\n    this.addResultData(uploadID, {\n      successful,\n      failed,\n      uploadID\n    });\n\n    // Update currentUpload value in case it was modified asynchronously.\n    currentUpload = getCurrentUpload();\n  }\n  // Emit completion events.\n  // This is in a separate function so that the `currentUploads` variable\n  // always refers to the latest state. In the handler right above it refers\n  // to an outdated object without the `.result` property.\n  let result;\n  if (currentUpload) {\n    result = currentUpload.result;\n    this.emit('complete', result);\n    _classPrivateFieldLooseBase(this, _removeUpload)[_removeUpload](uploadID);\n  }\n  if (result == null) {\n    this.log(`Not setting result for an upload that has been removed: ${uploadID}`);\n  }\n  return result;\n}\nUppy.VERSION = packageJson.version;\nexport default Uppy;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}